

2020.7
MAX_COMPNPASSSET は、3 では少なすぎるので増やすように。

t_compnpass に、flg int フィールドを追加
会社線乗り換え
鶴橋乗り換えで、広島発は許されて、新倉敷は許されないとか。どうする！？

会社線通過連絡運輸の場合、会社線通過の方が運賃が安い場合を採用するが、
IC運賃は、JR在来線のみの経路で運賃が安い方を採用すべきとなる。
  - 東京メトロ東西線(中野-西船橋)
  - 東京メトロ千代田線(西日暮里-北千住)
  例えば、三鷹~千葉みなとは、IC運賃は935円だが、紙のきっぷでは、800円を選べる

下記例は、旧バージョン(8455f45)の結果
1) -1 option
三鷹 -> 千葉みなと
経由：[中央東線]新宿,錦糸町[総武線]西船橋[京葉線(西船橋-南船橋)]南船橋[京葉線]
近郊区間内ですので最安運賃の経路にしました(途中下車不可、有効日数当日限り)
営業キロ： 60.0 km
運賃(IC)： ¥940(¥935)    往復： ¥1,880(¥1,870)
JR東日本 株主優待2割： ¥750
JR東日本 株主優待4割： ¥560
小児運賃： ¥470     往復： ¥940

2)
三鷹 -> 千葉みなと
経由：[中央東線]中野[東京メトロ東西線]西船橋[京葉線(西船橋-南船橋)]南船橋[京葉線]
近郊区間内ですので最安運賃の経路にしました(途中下車不可、有効日数当日限り)
営業キロ： 58.6 km
(JR線営業キロ： 27.8   km   会社線営業キロ： 30.8 km)
運賃(IC)： ¥800(¥473)  (うち会社線： ¥320)    往復： ¥1,600(¥946)
JR東日本 株主優待2割： ¥700
JR東日本 株主優待4割： ¥600
小児運賃： ¥400     往復： ¥800

8455f45だと、三鷹ー千葉は最短OKだが、三鷹ー蘇我は経路算出不能に陥る
仕様変更： 会社線を含んでいる場合は、
大都市近郊区間内で、会社線指定していた場合は、最短経路算出しないようにする
大都市近郊区間内で、最短経路を算出する際は、会社線を除外する。>してある
会社線使用のときはIC運賃はださないし、近郊区間云々の表示もしないし、最短経路算出もしない。（だしても嘘では？）

なぜか、以下がOKとなっている（経路通りではダメだが、最短算出でOK)
鶴橋 大阪環状線 京橋 片町線 放出 おおさか東線 久宝寺 関西線 天王寺 大阪環状線 x玉造

----
旅客営業規則157条の検討
関連：b#20012001

長崎 長崎線 浦上 長崎線(喜々津-浦上) 喜々津				25.1 ¥570
長崎 長崎線 喜々津								       18.4 ¥380

沼津 東海道線 小田原 東海道線 横浜							97.4 ¥1,690
沼津 東海道線 小田原 東海道新幹線 新横浜 					  97.4 ¥1,690
沼津 東海道線 小田原 東海道新幹線 新横浜 横浜線 菊名		   98.7 ¥1,690
沼津 東海道線 小田原 東海道新幹線 新横浜 横浜線 大口		   101.3 ¥1,980
沼津 東海道線 小田原 東海道新幹線 新横浜 横浜線 東神奈川       103.5 ¥1,980
沼津 東海道線 小田原 東海道新幹線 新横浜 横浜線 横浜 		   105.3  ¥1,980

沼津 東海道線 横浜 　　　　　　　　　　　　　　　　　　　　　　　97.4 ¥1,690
沼津 東海道線 東神奈川 									99.2 ¥1,690
沼津 東海道線 東神奈川 横浜線 菊名							 104.0 ¥1,980
沼津 東海道線 東神奈川 横浜線 大口							101.4  ¥1,980
沼津 東海道線 東神奈川 横浜線 新横浜 						105.3 ¥1,980　＞Yahooでは、¥1,690 となる

小田原 東海道線 東神奈川									56.9  ¥990
小田原 東海道新幹線 新横浜 横浜線 東神奈川						61.2 ¥1,170



高松\(讃\) 予讃線 宇多津 本四備讃線 茶屋町 宇野線 岡山 山陽線 神戸 東海道線 山科 湖西線 近江塩津 北陸線 金沢 IRいしかわ 津幡 七尾線 高松\(七\)






////

val build = AlertDialog.Builder(this).apply {
    setTitle(R.string.menu_item_import)
    setMessage(R.string.arch_title_import)
    setPositiveButton(R.string.agree) { _, _ ->
        saveParam(context, KEY_INPORT_AVAILABLE, "true")
    }
    setNegativeButton(R.string.arch_hide_specific_import, null)
}
val dlg = build.create()
dlg.show()
///
let actview = UIAlertController(title: "インポート", message: msg, preferredStyle: .alert)
actview.addAction(UIAlertAction(title: agree, style: .default) {
    action in
    /////
})
self.present(actview, animated: true, completion: nil)


val trv = archive_route_list.adapter
        as ArchiveRouteListRecyclerViewAdapter
trv.saveParams(this)




「経路保存画面」にて経路をクリップボードへエクスポートする機能と、クリップボードからインポートする機能を追加しました。
Android版は右上端のメニュー、iOSの下端バーのボタンをタップすると機能します。経路は行単位の文字列で１行1経路で複数行で複数経路を扱えます

エクスポート：全リスト
インポート：複数行

エクスポート（結果のやつと同じ実装）
インポート：複数行入力ダイアログを表示する方法



Archive
iOS archive view 無駄な保存を排除する

メイン経路は保存経路内の    existIndex 入れ換え SaveButton
a.  先頭にあり                 0       -        d
b.  先頭でないとこにあり        N       する      d
c.  なし                     -1      -         e    SaveButton押したら、saved; existIndex=0 aとおなじ
d.メイン経路自体なし           -2      -         d

existIndex == -1 -> button enabled.
existIndexは、a~dを識別する（重要）、操作により変更もされる

最初の状態
a)existIndex=0
0*
1
2
3
　　　　　　　　　　　　　　　　　　　　　　　 +-> select closeの例
b)existIndex=N                         v
0   2                     2            0   0    1
1   0                     0            3   2<   0
2*  1                     3  (index=2)     3    2
3   3   unsaved                  ^              3
                                 +-> swipe 削除の例 ふ
c)existIndex=-1
0   *
1   0
2   1
3   2
    3   unsaved
d)existIndex=-2
0
1
2
3

は
0    2                          0
1    0       swipe削除 idx=0 ->  1
2*   1                          3 saved
3    3 unsaved


* メイン経路


- 保存ボタン処理
c.未格納     index=0   existIndex<-
c.未格納     index=N
(ほかc以外は保存ボタンは押せない)

- Swipeによる削除時(index=0,N)
a.先頭にあり index=0 : 削除して保存、d(existIndex=-2)にする
a.先頭にあり index=N : 削除して保存
b.中間にあり index=0 : 削除して保存、d(existIndex=-2)にする(先頭に移動したものを削除したので保存して表裏一体となる)
b.中間にあり index=existIndex+N : 削除して保存、a(existIndex=0)にする。先頭がカレントとして保存されたので
b.中間にあり index=existIndex-N : 同上
b.中間にあり index=existIndex=N : 同上(NはすでにN-1にいる)
c.未格納     index=0 : 削除して(保存しないで)、d(existIndex=-2)にする。保存ボタン無効
c.未格納     index=N : 削除して, 先頭以外をSliceして保存
d.メイン経路なし index=0 : 削除して保存
d.メイン経路なし index=N : 削除して保存

a. d. そのまま、remove.index, saved index==0? existIndex=-2(same as 'd')
b.    index==0 ? remove.index; saved; existIndex=-2  (same as 'd') カレントが削除されたので -> は
      index>=1 ? remove.index; saved; existIndex=0 (same as 'a') 先頭がカレントで保存されたので　->ふ
c. index==0 ? remove.0; existIndex=-2 (same as 'd') 保存しない、ボタンDisable化
   index!=0 ? remove.N; index1~N(先頭Item以外)をsaved;


- 選択して閉じる
     a.先頭にありexistIndex==0 index=0 : なにもしないで閉じる
     a.先頭にありexistIndex==0 index=N : (入れ換え)
     b.中間にありexistIndex==N index=0 : なにもしないで閉じる
     b.中間にありexistIndex==N index=existIndex+N : （まとめ）
     b.中間にありexistIndex==N index=existIndex-N :　（まとめ）
     b.中間にありexistIndex==N index=existIndex=N :　（まとめ）
     c.未格納 existIndex==-1    index=0 : なにもしないで閉じる
     c.未格納 existIndex==-1    index=N : remove.0, index -= 1, (入れ換え) 保存されていないので1行目は削除しインデックスも−1して繰り上げた上で0ならなにもしないし、1以上なら入れ換え処理する
     d.メイン経路なしexistIndex==-2 index=0 : なにもしないで閉じる
     d.メイン経路なしexistIndex==-2 index=N : (入れ換え)

select & closed:（まとめ）
index==0 ? そのままClose(b.save())
index!=0 ? a. existIndex==0 ?  (入れ換え)
           c. existIndex==-1 ? index--
                            index == 0 ? そのままclose
                                   else  (入れ換え)
           b. existIndex>0   ? get.index -> index_str
                            remove.index; // 入れ替えるので削除
                            remove.0;     // 保存状態とおなじにする
                            insert.(existIndex < index ? existIndex : existIndex-1), currentRouteString
                            insert.0.index_str
                            save()
           d. existIndex==-2 ? (入れ換え)

　(入れ換え)
   if 0 < index
    remove.index
    insert.0, selstr
    save()
読み直すんだったら、
 existIndex == -1 で、

>>>コードにすると、
if index != 0
  if existIndex == -1
    index -= 1
  else if 0 < existIndex

まとめb
existIndex=2
0 aa       cc    cc       aa    aa     dd
1 bb       aa    aa       bb    bb     aa
2 cc*      bb    bb       ee    cc     bb
3 dd       dd    ee             ee     cc
4 ee       ee                          ee
ccが経路に入っていた
　　　　　　　     remove.index  insert.2
           ddを選ぶ      remove.0      insert.0.index_str
          (index=3)

existIndex=2
0 aa       cc    cc       aa    aa     bb
1 bb       aa    aa       dd    cc     aa
2 cc*      bb    dd       ee    dd     cc
3 dd       dd    ee             ee     dd
4 ee       ee                          ee
ccが経路に入っていた
bbをえらぶ        remove.index
(index=2)                remove.0      insert.0.index_str
                                insert.(2-1)




//以下参考


:初期化
if exist cur_route
 if exist cur_route in strage
   if 0 < exist_index
     remove.exist_index
     insert.0.cur_route # cur_route = exist_index
   saved = True
   button = false
 else
   insert.0.cur_route
   saved = false
   button = enabled
else
 save = True
 button = disable
〜初期化では保存しない

bの他(N=4とする)(existIndex=3)
         1)   2)  3) 4)
0: old3 old3  0   0  4
1: 0     0    1   1  0
2: 1     1    2   2  1
3: 2     2        3  2
4: 4                 3

bの他(N=2とする)(existIndex=3)
        1)   2)  3) 4)
0: old3 old3 0   0  1
1: 0     0   2   2  0
2: 1     2   4   3  2
3: 2     4       4  3
4: 4                4

bの他(N=existIndex=3とする)
        1)   2)  3) 4)
0: old3 old3 0   0  2
1: 0     0   1   1  0
2: 1     1   4   3  1
3: 2     4       4  3
4: 4                4


-- test
メイン経路　保存経路
なし　　　　　なし
あり　　　　　なし
あり　　　　　あり
なし　　　　　あり

あり0　　　　3
あり1　　　　3
あり2　　　　3
なし　　　　 3

あり0　　　　3  0-1-2と削除
あり1　　　　3
あり2　　　　3
なし　　　　 3

あり0　　　　3  1-2-0と削除
あり1　　　　3
あり2　　　　3
なし　　　　 3

あり0　　　　3  1-2-0と削除
あり1　　　　3
あり2　　　　3
なし　　　　 3


- インポートする
  インポートは後ろへ追加。既存のがあれば追加しないし、移動もしない。
  b.の場合はSwipe削除と同じく、強制的に並べ替えた状態(メイン経路が先頭に移動した状態)で保存
     a.先頭にありexistIndex==0 : 後ろへ追加して保存
     b.中間にありexistIndex==N : 後ろへ追加して保存 a(existIndex=2)にする
     c.未格納 existIndex==-1 : 後ろへ追加。先頭経路がImport側にあったなら, a(existIndex=0)にして(先頭経路も含め)保存する,
                                                          なければ、先頭経路のみ保存しない。
     d.メイン経路なしexistIndex==-2 : 後ろへ追加して保存


// fin

Windows10 Updateしたら、pythonが突然コマンドラインで使えなくなって困った。
急遽、PathにC:\Users\default.DESKTOP-5557AKR\AppData\Local\Programs\Python\Python36-32
を先頭に加えて対処.



CheckOfRule88j()


　　　　新大阪 →大阪
東海道線 神戸
山陽線 姫路

      xxx
山陽線 姫路
東海道線 新大阪->大阪

　　　大阪  　　　  　　　    大阪
(東海道線) 新大阪　(東海道線)　新大阪 → 東海道線 神戸 FLG_HIDE_LINE,FLG_HIDE_STATION
　　　　　　　 　　 山陽線 　　西明石 FLG_HIDE_LINE、FLG_HIDE_STATION (insert)
山陽新幹線 XXXX　　山陽新幹線 XXXX　　　　->>> 近郊区間除外＊

          xxx               xxx
山陽新幹線 新大阪  山陽新幹線  m西明石 FLG_HIDE_STATION＊
                  山陽線    神戸　FLG_HIDE_LINE|FLG_HIDE_STATION　(add)
(東海道線)  大阪   (東海道線)　大阪  FLAG_HIDE_LINE　　　->>> 近郊区間除外


      新大阪               m大阪
                  東海道線 神戸 (add) FLG_HIDE_LINE,FLG_HIDE_STATION
                  山陽線 西明石 (add) FLG_HIDE_LINE,FLG_HIDE_STATION
山陽新幹線 xxx     山陽新幹線 xxx　　　　->>> 近郊区間除外＊


       xxx         　　　　　　xxx
山陽新幹線 新大阪    山陽新幹線 西明石 FLG_HIDE_STATION  ->>> 近郊区間除外＊
                  *山陽線    神戸  -> (add)FLG_HIDE_LINE,FLG_HIDE_STATION
                  *東海道線 大阪   -> FLG_HIDE_STAION(add)



-- 2ch
拝島 → 大船　経由: 青梅,南武,東海道３,[鶴見],東海道
JR線(鉄道)営業キロ: 67.5km
普通片道運賃　　　　　：大人 1100円

拝島 → 大船　経由: 八高,横浜,相模,東海道
JR線(鉄道)営業キロ: 64.1km 運賃計算キロ: 65.1km
普通片道運賃　　　　　：大人 1170円


android 起動順序

FaretApp:onCreate()
          -> DatabaseOpenHelper
                 RouteDB
      MainActivity-onCreate()

--
ds.assign((application as FarertApp).ds, routeEndIndex)

mIsRoundTrip = ds.isAvailableReverse
setRouteOption(ds)  // setDetour()

mCalcRoute = CalcRoute(ds)
mCalcRoute?.let {
    it.calcFareInfo()

    val route = Route(it)
    // 経路設定フラグを設定)opt_xxxによって計算オプションを設定
    setRouteOption(route)   // もう一度やるのはcalcFareInfoのあとでないと
                            // route_flag.setXxx()で、urban_neerestやrule115が0以外(有効)
                            // にならず、セットが無視されてしまうから
    it.sync(route, -1)

    val fi = it.calcFareInfo()

    setContentData(fi)  // 表示計算結果
    // 設定可能フラグを設定(make opt_xxx)
    setOptionFlag(fi)   // getFareOption() -> this member attributes(opt_xxx)
}
--->すごく馬鹿臭い、なんとかせにゃ


* Android
　member: CalcRoute
  create:
   変数ロード
  onResume:
   Routeを一次変数で、フラグセットして、CalcRouteへコピー
   全変数をみて一括してフラグ設定 in setRouteOption()
   計算後に、全変数を更新 in setOptionFlag()

  onPrepareOptionsMenu() メニュー押されたときメニュー表示前に。
   メニューの表示を変数をみて制御 in menuControl()

  onOptionsItemSelected() メニュー選択されたとき
   変数を更新 -> onCreate() -> onResume()の流れへ
     => 変数を直接更新せずに、m_routeの変数を更新し、m_routeのフラグをもとに変数全部更新する。
        (changeOption()として実装)

* iOS
  actionSelectProc()
   個別にフラグをセットして計算して表示更新
  chgOptionButtonAction()
   計算結果からメニューを追加、表示を変える

* Windows
  resetMenu()
    m_route のフラグを見てメニューを一括制御している。(名阪は特例の中に入れられている)

  OnBnClickedMfcmenubuttonFareopt()
    menuにそって、m_routeのフラグをセットして計算して更新している->resetMenu()へ




darkMode 対応
defaultBackgroundColor
defaultButtonColor
linkColor
navigationBarTintColor
primaryTextColor
alertColor
borderColor


注意：
Javaのオブジェクトは参照なので代入に注意

オブジェクトを引数に持ち、
関数内部でメンバを書き換えれば、メンバは呼び出し側からみても書き換わっている。
ただし、

void func(Obj obj) {
   obj.member += 100;   // 呼び出し側にも反映される
}

void func(Obj obj) {
   Obj inobj = new Obj();
   inobj = 100;
   obj = inobj;     // 呼び出し側へは反映されない。
}
以上の例では,memberは上からみてコメントの通り。
obj = inobj; を消して(消さないとだめ)
obj.member = inobj.member;  //  // 呼び出し側にも反映される
とする。
Javaは参照渡しです。あくまでもポインタのコピーを渡す訳で、
ポインタのコピーの示す先を書き換えは上も下も影響を及ぼすが、
ポインタのコピーを書き換えたところで、戻ったら破棄されるもので（オーナーは関数内ローカル）ある。
//

2019.10.01
- alpdb.cpp, alpdb.h
Javaだとvirtual つけなくても、ポリモーフィズムが効くが、C++は効かない。
なので、
RouteList startStationId / endStationId()
CalcRoute beginStationId / endStationId()
となっているのを、
RouteList departureStationId / arriveStationId()
にする。



$/Applications/Android\ Studio.app/Contents/jre/jdk/Contents/Home/bin/keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key
/Applications/Android\ Studio.app/Contents/jre/jdk/Contents/Home/bin

pass: sute7840

---C++
FARE_INFO fi;
CalcRoute croute(route);
tstring s;

croute.refRouteFlag().setNoRule(true);
croute.calcFare(&fi);
s = fi.showFare(croute.getRouteFlag());
s = cr_remove(s);
_ftprintf(os, _T("///非適用\n%s\n"), s.c_str());
------
c_route.m
--
// fare calc
- (FareInfo*)calcFare
{
    FARE_INFO fi;
    int fare_result;

    obj_calcroute->calcFare(&fi);
    switch (fi.resultCode()) {
        case 0:     // success, company begin/first or too many company
            fare_result = 0;
            break;  // OK
        case -1:    /* In completed (吉塚、西小倉における不完全ルート) */
            fare_result = 1;     //"この経路の片道乗車券は購入できません.続けて経路を指定してください."
            break;
        default:
            return nil; /* -2:empty or -3:fail */
            break;
    }

    FareInfo* result = nil;
    string str1;
    :
    全必要情報がFareInfoに格納される


 ---
 self.fareInfo = self.ds.calcFare()
if self.fareInfo == nil {
    self.navigationItem.title = "エラー"
    self.navigationItem.prompt = ""
    return
}
----------- android(既存)

val ds = Route()
ds.assign((application as FarertApp).ds, routeEndIndex)
setRouteChange(ds)
mIsRoundTrip = ds.isRoundTrip
mCalcRoute = CalcRoute(ds).also {
    it.calcFareInfo()   // apply lastFlag.rule_en
    setRouteOption(it)  // setFareOption()
}

.... onResume()
mCalcRoute?.let {
    val fi = it.calcFareInfo()
    setContentData(fi)
    setOptionFlag(fi)   // getFareOption() -> this member attributes(opt_xxx)
}

mCalcRoute どうせこわれるならメンバにおいても。。。グローバル変数として有用


-----


b#19082201
getDistanceEx() のあと
TRACE("\n\n\n\n@@@@@@@@@ %d, %d, %d, %d\n", company_id1, sub_company_id1, company_id2, sub_company_id2);
TRACE("@@@@@@@@@ %d, %d, %d, %d\n\n\n", result[0], result[1], result[2], result[3]);

新山口 門司  4, 0   5, 0  752,0,689,0
門司 新山口  5, 0   4, 0  752,0,63,0 　
宇多津 茶屋町 6, 4   4, 0  310, 0, 181, 0
茶屋町 宇多津 4, 0   6, 4  310, 0, 129, 0
宇多津 児島  6, 4,  4, 0   181,0, 0, 0
児島 宇多津 4, 0,  6, 4   181,0,0,0  NG

下関 門司　  4, 5   5, 0  63,0,-1,0  OKだけど飛ぶ JR本 しかないとおもわれている
門司 下関    5, 0   4, 5  63,0,0,-1 　NGだけど飛ばない JR九がないものとされている

幡生 下関 4,0 4,5
下関 幡生 4,5 4,0

茶屋町 宇多津 4,0  6,4   310, 0  129, 0
宇多津 茶屋町 6,4  4,0   310, 0  181, 0

if (IS_JR_MAJOR_COMPANY(company_id1) && IS_JR_MAJOR_COMPANY(company_id2) && (company_id1 != company_id2)) {
  if (sub_company_id1 == company_id2) {
      company_id1 = sub_company_id1;
  }
  else if (company_id1 == sub_company_id2) {
      company_id2 = sub_company_id2;
  }
  3島会社で駅１と駅２が異なる時、内側が同じなら、1<-内
  　　　　　　　　　　　　　　　 外側が同じなら、2<-外

>>
if (company_id1 != company_id2) {
    if (IS_JR_MAJOR_COMPANY(company_id1) && IS_JR_MAJOR_COMPANY(company_id2)) {
        }
    } else {
        if (sub_company_id1 != 0 || sub_company_id2 != 0) {
            if (company_id1 < company_id2) {
                /* 四国、 九州 にする */
                company_id1 = company_id2;
            } else {
                company_id2 = company_id1;
            }
        } else {
            /* 新山口 - 門司 とか */
        }
    }
}

<<
本四備讃線の宇多津は
DBを、JR四国/JR西日本であったけど、JR西日本/JR四国にした。

松山 岡山 営業キロ 2144 JR四国以下
OK    NG   差
1866 1995 12.9



///////////////////////////////////////////////////////////
d#19080001>>
b#19081602
b#19070601
b#18111401

v 代々木 山手線 池袋 埼京線 大宮 川越線 高麗川 八高線 用土
-> 最安経路になってない。値段と表示経路に矛盾が。。。>OK

v 大正 大阪環状線 大阪 東海道線 草津 草津線 柘植 関西線 木津 片町線 京橋 大阪環状線 今宮
-> なんで名阪がつくの？ 強引に修正した

v 小岩 総武線 西船橋 武蔵野線 新松戸 常磐線 植田
-> 単駅、都区市内選べるのが良いが、都区市内になってない。

蒲田 東海道線 東神奈川 横浜線 八王子 中央東線 茅野
同様

v 代々木 中央東線 八王子 八高線 用土
同じく


//

京都 東海道線 尼崎 福知山線 谷川 加古川線, 加古川 山陽線 西明石 山陽新幹線 e新大阪
-> 近郊区間では無いかい！？>否、合ってる！

亀有 常磐線 我孫子 成田線(成田-我孫子) 成田 成田線 佐倉 総武線 東京 東海道新幹線 品川
-> 最安運賃にされたのは良い。Optionは効くかな？

v 勝浦 外房線 千葉  総武線 東京 OK
v東京 京葉線　蘇我　外房線　勝浦 NG
v  東京,京葉線,蘇我,内房線,袖ケ浦はOKなのに。
v勝浦,外房線,蘇我,京葉線,東京
v -> 京葉線経由となっている
v東京,総武線,千葉, 外房線,勝浦 NG
v ->わざわざ京葉線にされちゃっている。

v 新横浜 横浜線 東神奈川 東海道線 川崎 南武線 府中本町 武蔵野線 西国分寺 中央東線 立川 青梅線 福生
v 920円なのに970円

蒲田 東海道線 川崎 南武線 立川 中央東線 八王子 八高線 倉賀野 高崎線 高崎 上越線 新前橋 両毛線 小山 水戸線 友部 常磐線 我孫子 成田線\(成田-我孫子\) 成田 成田線 佐倉 総武線 西船橋 武蔵野線 南浦和 東北線 日暮里>
大回りなのに。まぁいいけど。なんでだっけ？




　新大阪 東海道新幹線 名古屋 中央西線 恵那
 板橋 埼京線 赤羽 東北線(尾久経由) 日暮里 東北線 東京 東海道新幹線 名古屋
 長津田 横浜線 新横浜 東海道新幹線 名古屋
 保津峡 山陰線 京都 東海道新幹線 新横浜
v 渋谷 山手線 田端 東北線 東京 東海道線 横浜        　       なぜか経路が今一歩遠回り
v 大阪 東海道線 草津 草津線 柘植 関西線 今宮 　              都区内発着=86適用できちゃぁだめっしょ
大阪 東海道線 草津 草津線 柘植 関西線 天王寺 大阪環状線 鶴橋
v  蒲田 東海道線 川崎 南武線 立川 中央東線 八王子 八高線 倉賀野 高崎線 高崎 上越線 新前橋 両毛線 小山 水戸線 友部 常磐線 我孫子 成田線\(成田-我孫子\) 成田 成田線 佐倉 総武線 西船橋 武蔵野線 南浦和 東北線 日暮里>

v 神戸 東海道線 京都 奈良線 木津 片町線 京橋 大阪環状線 e大阪　最安の経路にしました〜って33kが150k越えじゃん。特別運賃の処理ですな
v 神田 東北線 東京 東海道新幹線 三島 東海道線 富士 身延線 甲府
v 新大阪 東海道新幹線 熱海  株主優待Optionが提示されない。論理が逆だぜ






fi.calc_fare(raw, cooked)
  cookedが空ならrawとしてつかっている。rawのみ、cookedのみは不使用
  aggregate_fare_info(raw, cooked)


FARE_INFOとCalcRoute
なんで別なの？
一緒にすると？

FARE_INFO fi;
CalcRoute croute(route);
croute.calcFare(&fi);
s = fi.showFare(croute.getRouteFlag());

CalcRoute croute(route);
croute.calcFare();
croute.showFare();

のほうがスッキリでは？？？
Androidは、FareInfoで被せているし、もういいや。

Flag

Bullet
Urban



FARE_INFOはcrouteの内部に隠蔽？

bool bUnconditionBulletCheck = !pRoute_flag->rule70 && !pRoute_flag->rule86or87 &&
                             (0x03 != (0x03 & ((pRoute_flag->rule86or87 >> 2) |
                                                pRoute_flag->rule86or87)));
:
cityId_c = (uint16_t)MASK_CITYNO(ite->flag);
if ((bUnconditionBulletCheck || ((cityId == 0) || (cityId_c == 0))) &&
    IsBulletInUrban(ite->lineId, station_id1, ite->stationId)) {
    pRoute_flag->bullet_line = true; // ONの場合大都市近郊区間特例無効(新幹線乗車している)
}


都区市内区間外 　|         |
(一部含)       |         |
cityId == 0|| | rule70  |  rule86or87
cityId_c == 0 |         |
--------------+---------+------------
    F(区間外)      F          F         -> T  区間外なのでチェックする 区間外は無条件で近郊間内新幹線NGなので
    F             F          T         -> T 仙台->遠く とか。普通の。
	F             T          F         -> T 100km未満　千葉-立川 とか。千葉 東京 上野 大宮 とか。新幹線チェックも不要では？
	F             T          T         -> T 仙台->東京->どっか とか
	T             F          F         -> T 100km未満か。乗ったことにする。東京 品川 茅ヶ崎 とか。
	T             F          T         -> F 亀有-品川の例 で新幹線乗車は乗ったことにしたく無い
	T             T          F         -> F ありえる？ 都区内通過して戻ってきて？　品川 東京 西船橋 秋葉原 八王子 とか
	T             T          T         -> F　ありえない。70と86の同時適用はありえない。あったとしても名古屋-仙台とか？

ciryId が変わらない新幹線乗車は東京上野品川以外にない。どこも同一特定区間内で新幹線の駅は2駅以上はない
X && shinkansen() -> useBullet
 　useBullet = true

->T 新幹線チェックをおこなう。チェックによって新幹線に乗ったか否かを設定する
->F 新幹線チェックしない。新幹線は乗ってないものとする

つまり、、、~b~c + ~a

if (( !rule70 && !rule86or87 || ((cityId != 0) && (cityId_c != 0))) && IsBulletInUrban()) {

}
にできる。

//

亀有 常磐線 我孫子 成田線\(成田-我孫子\) 成田 成田線 佐倉 総武線 錦糸町 総武線\(錦糸町-御茶ノ水\) 秋葉原 東北線 東京 東海道新幹線 品川
高崎 高崎線 大宮 埼京線 池袋
高崎 高崎線 大宮 東北線 赤羽 埼京線 池袋
小岩 総武線 西船橋 武蔵野線 新松戸 常磐線 植田
蒲田 東海道線 東神奈川 横浜線 八王子 中央東線 茅野
蒲田 東海道線 東神奈川 横浜線 八王子 中央東線 上諏訪
西荻窪 中央東線 松本
西荻窪 中央東線 茅野
浮間舟渡 埼京線 池袋 山手線 新宿 中央東線 松本
武蔵小杉 南武線 府中本町 武蔵野線 武蔵浦和 埼京線 赤羽 東北線 東京 東海道線 品川
武蔵小杉 南武線 府中本町 武蔵野線 西船橋 総武線 東京 東海道新幹線 品川
武蔵小杉 南武線 府中本町 武蔵野線 西船橋 総武線 東京 東海道線 品川
新宿 山手線 品川 東海道新幹線 東京 東北新幹線 那須塩原
豊田 中央東線 代々木 山手線 品川 東海道新幹線 東京 東北線 日暮里 常磐線 水戸			<< とちゅげダメの1日
豊田 中央東線 八王子 横浜線 東神奈川 東海道線 品川 東海道新幹線 東京 東北線 日暮里 常磐線 水戸	＜＜とちゅげOKの2日きっぷ



            a             b            c
            経路中心      最短中心     単駅            備考(経由)      えきねっと
1  高崎 池袋  　  105(¥1940)  105(¥1940)! *973(¥1660) 　　大宮　　　　　¥1940 a,b
2  代々木 用土   1029(¥1940)　 982(¥1940)　*933(¥1660)!　　立川拝島　　　立川拝島経由で1660
3  小岩 植田  　  202(¥3670)　1936(¥3350)! *1892(¥3350)!   西船橋、新松戸　　3350 西船橋、新松戸。東京からの最短は日暮里
4  蒲田 茅野     2174(¥3670)　1952(¥3350)! 2030(¥3670)　 東神奈川 　    ¥3350東神奈川でも東京経由でも.  単駅最短(立川)1970(3350)
5  蒲田 上諏訪   2181(¥3670)!　2019(¥3670)! 2097(¥3670)!　 東神奈川経由 　 ¥3670 新宿経由も東神奈川経由も 単駅最短(立川)も2037(3670)
6  蒲田 松本     2576(¥4430)　2354(¥4000)! 2432(¥4430)　　東神奈川　　　 ¥4000東神奈川でも東京経由でも 単駅最短(立川)2372(4000)
7  西荻窪 松本  　2354(¥4000)! 2354(¥4000)! *2138(¥3670)  最短　　　　　　¥4000
8  浮間舟渡 松本　2523(¥4430) 2354(¥4000)!　*2360(¥4000)! 　　　　　　　　　¥4000
9  西荻窪 茅野  　　　　　　　　　　　　　　　　　3030　　　　　　　　　　　　　　　　　¥3030
10 蒲田 信濃大町 2927(¥5080)!  2705(¥4750)! *2783(¥5080)　  東神奈川　　　　 東神奈川経由で5080 東京経由で4750
代々木 用土　c単駅最短は立川拝島で933(¥1660)
 　a単駅最短に沿った[山]で1029(¥1940)
   b最短中心は大宮経由で982(¥1940)
えきねっとが最短中心を選んでいるのか？単駅最短を選んでいるのか？どっち？？？例が見つからない・・・

都区内適用中心駅からの最短>a
単駅で最短>b
八高線>c.   from b
If c <b ?
    b <- c
If a is 86or87?
    Result is a
Else
     Result is b.    Assert  fate is b < a

RouteFlagは


近郊区間内＋8687
最短中心駅
最短単駅

最短中心が100越えないと都区内発は有り得ない(用土)
最短中心が100越えたら単駅安くても採用されない(池袋)

西荻窪 茅野3030で都区内ではない,
蒲田茅野は最短単駅

●0 Finalまとめ
A.近郊区間内で指定経路が8687適用で、最短中心が8687適用ならその運賃を採用（最短中心駅で算出）1, 3, 5,6,7,8
X B.近郊区間内で指定経路が8687適用で、最短中心が8687適用できないなら単駅の運賃と比較し、安い方を採用 4
C.近郊区間内で指定経路が8687適用で、最短中心が8687適用できないなら単駅の最安経路 2、４

Cをみるに、謎だった4は、Cの最短単駅！？
Cは115だとおもうが、Cの単駅最短＞最短中心 の例は？
Aで最短中心より単駅が安いとしても単駅で

(規程115)"当該中心駅からの最も短い営業キロが200km以内となるときに限り、規則第86条の規定を適用しないで、
発駅から実際の営業キロ又は運賃計算キロによつて計算することができる。"

2と4は東京都区内[区]発に変更可能です。というオプションを追加する。
適用後は最安経路が選択可能にするオプションを追加する。
「特定都区市内(発着)」に変更可能です。にする。> opt_specific_terminal

経路と最短が50キロ離れてたら最安経路指定できます／指定経路の切り替え可能 > opt_lowcost_route
opt_はcharで、0 無効 1 有効 −1無効

●1 駅1〜駅2 が70の経路内か？
(70適用していることが条件)
reCalcの先頭でOK

　新幹線乗車は上野、東京 か？
 　　ID_L_RULE70の経路が、以下ならOK
　品川、日暮里
　日暮里、東京
　東京、赤羽
　赤羽、錦糸町
    のどれか。　
  新幹線乗車は、東京、品川か？
品川	日暮里
品川	東京
品川	赤羽
品川	錦糸町
東京	赤羽

というテーブルを作って該当すれば近郊区間内新幹線乗車としてみなす
テーブル名, t_r70bullet
station70_id1, station70_id2
station_id1, station_id2

unique station_id1, station_id2
station70_id1,  ... station_id2
東京	品川	品川	日暮里
東京	品川	品川	東京
東京	品川	品川	赤羽
東京	品川	品川	錦糸町
東京	品川	東京	赤羽
上野	東京	品川	日暮里
上野	東京	日暮里	東京
上野	東京	東京	赤羽
上野	東京	赤羽	錦糸町
*//

●2 駅1〜駅2 が86の経路内か？
（●1のt_r70bulletでFalseのときで、8687適用時(最短適用ではなく経路適用でOK))
新幹線乗車が上野、東京かまたは、東京、品川か？
それは終端か？先頭か？ 　checkTrailSpecificTerm(station_id1, station_id2), checkFailSpecificTerm(station_id1, station_id2)
-> 86or87か？  　　　　どこでやるか？経路適用でOKなのでreCalcの先頭でOK

●1も●2もreCalcの前でやる。



<<d#19080001
---
reCalcFareForOptiomizeRouteの現処理

shortRouteに最短経路作成
route_via_tachikawaに立川、拝島経由に変更した経路を作成（とおっていれば）
上の３経路で、一番安い経路をFARE_INFOに適用させて戻る。

--

近郊区間内ですので最安運賃の経路にしました(途中下車不可、有効日数当日限り)
はおかしい。
近郊区間内ですので最安運賃の経路で計算(途中下車不可、有効日数当日限り)
が正しい。

また、最安経路にした場合は特例非適用が選べる


改修終了
フラグが、RouteFlagにあったり、calcRouteにあったりごちゃ混ぜで分かりづらい
それは許せるとしても、FARE_INFOにもあったりするともう最悪。
iOS, Androidは上記らは統合するから良い？

calcFare()
shorRoute()

非適用ー＞適用は可能
通常は、適用ー＞非適用を想定 RouteFlagを保持したまま
非適用ー＞8687非適用はNG



val rc = ds.setDetour( (opt_osakakan == Option.DO_TRUE)  )  // 遠回り・近回り

// 特例
 if (Option.DO_TRUE == opt_sperule) {
     // @"特例を適用しない";
     ds.setFareOption(RouteUtil.FAREOPT_RULE_NO_APPLIED, RouteUtil.FAREOPT_AVAIL_RULE_APPLIED)
 } else if (Option.DO_FALSE == opt_sperule) {
     // @"特例を適用する";
     ds.setFareOption(RouteUtil.FAREOPT_RULE_APPLIED, RouteUtil.FAREOPT_AVAIL_RULE_APPLIED)
 }

 // 大高-杉本町
 if (Option.DO_TRUE == opt_meihancity) {
     // "着駅を単駅指定";
     ds.setFareOption(RouteUtil.FAREOPT_APPLIED_START, RouteUtil.FAREOPT_AVAIL_APPLIED_START_TERMINAL)
 } else if (Option.DO_FALSE == opt_meihancity) {
     // "発駅を単駅指定";
     ds.setFareOption(RouteUtil.FAREOPT_APPLIED_TERMINAL, RouteUtil.FAREOPT_AVAIL_APPLIED_START_TERMINAL)
 }

 // JR東海株主
 if (Option.DO_FALSE == opt_stocktokai) {
     // @"JR東海株主優待券を適用しない";
     ds.setFareOption(RouteUtil.FAREOPT_JRTOKAI_STOCK_NO_APPLIED, RouteUtil.FAREOPT_JRTOKAI_STOCK_APPLIED)
 } else if (Option.DO_TRUE == opt_stocktokai) {
     // @"JR東海株主優待券を使用する";
     ds.setFareOption(RouteUtil.FAREOPT_JRTOKAI_STOCK_APPLIED, RouteUtil.FAREOPT_JRTOKAI_STOCK_APPLIED)
 }


FARE_INFO fi;
croute.calcFare(&fi);
s = fi.showFare(croute.refRouteFlag());
:
int flag = fi.enablesRules();  appliedRules()とは別でability,capabilityを返す
:
FARE_INFO fi(flag);
fi.setFareOption(flag);     階層構造とフラグの使い所
croute.calcFare(fi);
  checkOfRuleSpecificCoreLine
    setTerminal
    fi.calc_fare(pRoute_flag, RouteList)      このあとのために
     fi.aggregate_fare_info(RouteFlag)     JR東海関連でセット。大阪環状線フラグは参照
       GetDistanceEx(RouteList)               大阪環状線フラグ
     fi.aggregate_fare_company(RouteFlag)    会社線通過フラグを参照
    fi.reCalcFareForOptiomizeRoute(RouteList)  (フラグは未使用)
    fi.setRoute(RouteList, RouteFlag) ->   RouteUtil::Show_route(routeList, rRoute_flag) 大阪環状線フラグを利用
    CalcRoute.beginStationId(applied_agree)   applied_agreeはbool特例適用か否か=単駅使用か特定都区市内か？
    CalcRoute.endStationId(applied_agree)
    fi.setRoundTrip()
    fi.setEnableRules()



2019-08-11
大改造
FARE_INFO.calc_fare() -> CalcRouteのメンバへ。
CalcRoute.calc_fare(FARE_INFO fi, )
->断念　calc_fareはいろいろ使われるので面倒




2019-08-10
LAST_FLAG周りをAndroidライクにした。
ビットいじりはヤメ。


Disable_Rule ビットがONなら禁止。デフォルトAll0
Avail_Rule 　ビットがONなら該当。 実行後にわかる

FARE_INFOが持つ。CalcRouteのLast_Flagからもらう。
Last_Flagは増やし、RuleFlagを設ける。ビットフィールドにする。か。
FARE_INFOはFILE構造体のようにアプリ側で持たせ捨てさせない。
いまのように、getFareOptionとかでcalcRouteは無駄なのでやらせない。
Androidのようにオブジェクト保持が面倒な場合（できなくはないが）、
int値のFARE_INFO圧縮値をもつ。packedValue ? handle, identifier, flag, fi_id ? fi_idに決定
RuleFlag
  86,87
  69
  70
  88
  近郊最短

test_exec.cpp の以下はどーする？
  croute.setFareOption(FAREOPT_RULE_NO_APPLIED, FAREOPT_AVAIL_RULE_APPLIED);
  s = croute.showFare();
  s = cr_remove(s);
  _ftprintf(os, _T("///非適用\n%s\n"), s.c_str());
--
tstring CalcRoute::showFare()
{
#define MAX_BUF	1024
	TCHAR cb[MAX_BUF];
	tstring sResult;
	tstring sWork;

    FARE_INFO fare_info = calcFare();
----

  FARE_INFO fi = croute.calcFare()
  s = fi.showFare();

  とする

  getFareOption() なくす？
  setFareOption() なくす

  FARE_INFOに、getFareOption()をバラしたメソッドを含める

  test_exec()は、
0)-------------------(now)
 Route route;
 CalcRoute croute(route):
 s = croute.showFare();
 :
 int flag = croute.getFareOption();
 croute.setFareOption();
 s = croute.showFare();
 :

 FARE_INFO fi = croute.calcFare()
 は、iOS, android、Winは、croute.showFare()の中にいる。


1)-------------------
  FARE_INFO fi = croute.calcFare()
  s = fi.showFare();
  :
  int flag = fi.getFareOption();
  fi = croute.calcFare(flag); // flag is bitpattern NO_RULE that all on .
  s = fi.showFare();
  -> fiを2回上書きするのがキモい
2)-------------------
  FARE_INFO fi;
  croute.calcFare(&fi);
  s = fi.showFare();
  :
  int flag = fi.enablesRules();  appliedRules()とは別でability,capabilityを返す
  :
  FARE_INFO fi(flag);
  fi.setFareOption(flag);
  croute.calcFare(fi);
  -> なんか冗長っぽい。直感的でなくまどろっこしい
3)----------
  FARE_INFO fi(croute(route));
  fi.calcFare()
  s = fi.showFare();
  int flag = fi.getApplyRules();
  flag &= ~DISABLE_APPLY;
  fi.calcFare(flag);
  fi.showFare();

  -> これできまり！！
  cRouteを持つので大きくなるがいずれにしてもとなりにいるのだから関係ねし。

＝＝＞やっぱ3辞め、2)にする。


calcRoute.getFareOption()
 で得られるものを、FareInfoへ
 //     & 0x03 = 0 : 無し(通常)(発・着が特定都区市内駅で特定都区市内間が100/200km以下ではない)
 //			 (以下、発・着が特定都区市内駅で特定都区市内間が100/200kmを越える)
 //	   & 0x03 = 0x01 : 結果表示状態は{特定都区市内 -> 単駅} (「発駅を単駅に指定」と表示)
 //	   & 0x03 =	0x02 : 結果表示状態は{単駅 -> 特定都区市内} (「着駅を単駅に指定」と表示)
 fun isMeihanCityStartTerminalEnable() : Boolean = (calcResultFlag and 0x03) != 0x00  名阪有効で、
fun isMeihanCityStart() : Boolean = (calcResultFlag and 0x03) == 0x01 　　　　　　　　　開始が
fun isMeihanCityTerminal() : Boolean = (calcResultFlag and 0x03) == 0x02

// bit 2-3
fun isOsakakanDetourEnable() :Boolean = (calcResultFlag and 0x0c) != 0x00

// TRUE: Detour / FALSE: Shortcut
fun isOsakakanDetourShortcut() : Boolean = (calcResultFlag and 0x0c) == 0x08

// bit 4-5
fun isRuleAppliedEnable(): Boolean = (calcResultFlag and 0x30) != 0x00
fun isRuleApplied(): Boolean = (calcResultFlag and 0x30) == 0x10
fun isFareOptEnabled() : Boolean = (calcResultFlag and 0x33f) != 0x00

// bit 8-9
fun isJRCentralStockEnable(): Boolean = (calcResultFlag and 0x300) != 0x000　　Trueなら有効で、False:非該当
fun isJRCentralStock() : Boolean = (calcResultFlag and 0x300) == 0x200　　　　　Trueなら適用されていて、False：未適用

>>>>>>>



........................................

大都市近郊区間適用　19.8.1

  近郊 86 新幹 最短 日数 近郊         x   特例 特例非適用時
 1 T   T  F : n    1   Y(最短可能)  ac  y    ad
 2 T   T  T : n    1   Y(最短可能)  ac  y    ad
 3 T   F  F : Y    1   Y           b   n
 4 T   F  T : n    *   n           -   n
 5 F   -  - : n    *   n           -   n

 最短は復活
 [近郊区間内ですので最短経路の運賃で利用可能です(途中下車不可、有効日数当日限り)] -a
 は、近郊区間で特例非適用時に表示していた。
[近郊区間内ですので最安運賃の経路にしました(途中下車不可、有効日数当日限り)] -b

[または、「特例非適用」で単駅発着が選択可能です.] - c
[または、「特例適用」で特定都区市内発着か選択可能です.] - d

最短算出するのは,     近郊 and !86 and !bullet  3
最短算出有効なのは、   近郊 and 86
有効日数を1にするのは, 近郊 and (86 || !bullet)  1,2,3
showFare()でメッセージa: 近郊 and 86
         メッセージb: 近郊 and !86 and !bullet
         メッセージc: 86 is Tのとき
calc_route.BLF_NO_RULE -a

適用
NO_RULEがONでも86,87を無効にしているのか、69を無効にしているのか、70を無効にしているのかわからん。
NO_RULEがONでも
adは、わからへんのでは？86、87が適用できる実力かはNO_RULEがONではわからなくなってしまう。

蒲田 東海道線 川崎 南武線 立川 中央東線 塩尻 篠ノ井線 松本
は、神田経由で計算されていたが、今度は、南武線経由となる。






1=前谷地, 2=柳津

?1 line_id1
?2 stid1
?3 stid2
?4 brtid1
?5 brtid2
sales_kmは?4<?5
?2と?3は入れ違いあり


1 a b 2 : a-b 全線内なのでそのまま brt_sales_km -= (a-b)
1 a 2 b : a-2                                    brt_sales_km -= (a-2)
1 2 a b : 0　　通ってないので変換なし brt_sales_km -= 0
a 1 2 b :  brt_sales_km -= (1-2)
a b 1 2 : 0
a 1 b 2 : brt_sales_km -= (1-b)

-> brtexp.py

2019.07.01
会社線営業キロ

0 < total_jr_calc_km && total_jr_sales_km == total_jr_calc_km 計算キロあり
getCompanySalesKm() = sales_km - total_jr_sales_km;

brt kmは、total_jr_sales_km - brt_sales_km

brt_sales_kmは作成する(会社線はなかったがBRTは作成する)
total_jr_sales_km はBRT営業キロを含む？
total_jr_calc_km は？

int32_t company_fare;				/* 会社線料金 */
int32_t company_fare_ac_discount;	/* 学割用会社線割引額 */
int32_t company_fare_child;			/* 会社線小児運賃 */

データ構造(FARE_INFO)
int32_t brt_fare
int32_t brt_sales_km
int32_t brt_calc_km
int32_t brt_discount_fare
を追加する


BRT運賃計算処理概要
aggregate_fare_jr()で、
 line_idがBRTならBRTの営業キロを加算する。
(brt_sales_kmの更新)

こここで、前谷地-柳津の除外処理もする。＞しない
// 路線内の駅1〜駅2が、駅3〜駅4内に含まれるか？重なる部分の営業キロ、計算キロを返す
// -----
//   == 　　==を返す
// --
//    == 　0を返す
// ----
//   ====  ==の距離を返す
// ----
// ====    ====の距離を返す
// line_id [in] 路線
// station_id1 [in] 検査する駅1
// station_id2 [in] 検査する駅2
// station_id3 [in] 検査する駅3
// station_id4 [in] 検査する駅4
int32_t inlineOnline(int32_t line_id, int32_t station_id2, int32_t station_id2, int32_t station_id3, int32_t station_id4);
 ->テーブルから引数
 前谷地-柳津なら0以外の値が返ってくるので、sales_km, calc_kmに加算する

t_brtsp

retr_fare()のなかの先頭で,経路でまわし. brt_sales_km = 0ならなんにもしない。
retr_fare

for line_id, station_id1, station_id2 in route_list:
  if not BRT line:
    flg = 0
    for stid1, stid2, type in query(t_brtsp where line_id):
      n = inlineOnline(lid, station_id1, station_id2, stid1, stid2)  # 既存inStation()の検査対象駅が1つでなく2つにしたもの(AND条件)
      if n != 2:
        discount = false; // brt乗り継ぎ割引は無効
      endif
      flg = 1
    next
    if flg == 0: //テーブルレコードなし
       discount = false;  // brt乗り継ぎ割引は無効
    endif
   endif
//

BRTのみ
BRT+JR非割引区間
BRT+JR非割引区間
会社線区間は関係ない。

aggregate_fare_infoループないですべておこなうか？独立して行うか？
BRTのみは、brt_sales_km != 0 && total_sales_km == 0





DB Scriptで、柳津-前谷地の路線IDを落とす。＞辞め

前谷地-気仙沼 の扱い
前谷地-気仙沼は、BRTでも鉄道線の扱い。
経路から前谷地-気仙沼のキロを追加する。
BRT線内に、前谷地-気仙沼線のマイナス分を得る。
-----
  ======
なら、重なる部分のキロを返すクエリを作成する。


km = diff_overlap_route(line_id, station_id1, station_id2)






2019.06.30
jrsutezo.docx 改訂
lflg.18 を空きとする(会社線フラグ廃止)会社線はline_idで見分けられることとと認め不要になった

2019.6.27
やりたいこと。
InStation2(station_id1, station_id2, line_id, r_station_id1, r_station_id2)
  line_idのr_station_id1からr_station_id2の範囲内にstation_id1~station_id2の全駅が含まれているか？

  →要らない？
  2回inStation()を実行すれば良いだけ。

  石巻-福田町、陸前原ノ町-仙台
  は、
  石巻-仙台 とした際には、石巻は前者に含まれるが、後者には含まれない。

  もしやりたい場合でも、
  select count(*)
  	from t_lines
  	where line_id=?1
  	and station_id in (select station_id from t_lines
                        and (lflg&(1<<31))=0
                      	and sales_km>=
                      			(select min(sales_km)
                      			from t_lines
                      			where line_id=?1
                      			and (station_id=?4 or
                      				 station_id=?5))
                      	and sales_km<=
                      			(select max(sales_km)
                      			from t_lines
                      			where line_id=?1
                      			and (station_id=?4 or
                      				 station_id=?5))
                       )
  	and (lflg&(1<<31))=0
  	and sales_km>=
  			(select min(sales_km)
  			from t_lines
  			where line_id=?1
  			and (station_id=?2 or
  				 station_id=?3))
  	and sales_km<=
  			(select max(sales_km)
  			from t_lines
  			where line_id=?1
  			and (station_id=?2 or
  				 station_id=?3));
でいける。





aggregate_fare_info


志津川ー新庄は？ えきすぱあとは全鉄道線として計算している。2590円
              否、新庄-柳津(2,270) + 柳津-志津川(320) = 2590
              ()はFarert16.03で計算)

BRTを実装しました。
路線名にBRTと含まれている場合はBRTとなります。
BRTは営業キロは通算しますが運賃計算は会社線と同様打ち切って計算します（通過前後のJR線は通算します）。
柳津-前谷地は鉄道も並走しますがこの区間のBRT線は鉄道線として扱われます、
BRTと鉄道線の乗り換え範囲は以下にしめす鉄道線は¥100割引されます
https://www.jreast.co.jp/railway/train/brt/guide.html
BRTと鉄道線、会社線の利用制限はBRT=JRグループ鉄道線としています(現状と同じく)。
以上です。ルールが異なるということでしたら直ちに修正対応しますのでご一報ください。




2019.6.21
路線IDをIDで新幹線、会社線、BRTかを分けられるように
いままでしようとしてなぜそれができなかったのか？？？？
Pythonスクリプト変えてみてBranch BRTで試してみる。



2019.6.20
- BRT対応
  路線名はBRTとする。Pythonスクリプトで、路線IDを+10000 する
  大船渡線 盛-気仙沼間は、大船渡線(BRT)とする。既存の大船渡線は一ノ関-気仙沼間に短縮する
  気仙沼線(BRT)を追加。気仙沼-前谷地 とする。既存の気仙沼線は、柳津-前谷地に短縮する。（気仙沼線 柳津-前谷地は並走区間）

 　並走区間(前谷地-柳津)は鉄道と乗り継いでも通算する。

  路線IDを以下とする。
  #新幹線 0x1000~
  #会社線 0x2000~
  #BRT   0x3000~

  t_brtsp を追加 BRT-鉄道乗り継ぎで、¥100をマイナスする区間を定義（駅1、駅2、路線, type）
  type=0は乗り継ぎ割引期間
      =1はBRT線だがBRT線とはしない区間

- エクスポート／インポート対応(iOSとAndroidのみ)
経路保存画面でインポートとエクスポートのアイコンボタンを設置する。
 - インポートボタン
  「クリップボードの内容を取り込みますか？」（はい・いいえ）
   リストの前段に追加する。全体のMAXに溢れたら（最大XX件までですので、XX件は漏れました）と表示
   「XX件取り込みました. 青色の文字の経路です。保存ボタンを押すまでは保存はされません」
   青字にする

 - エクスポートボタン
  「経路をクリップボードへエクスポートしますか？クリップボードは破棄されます」（はい、いいえ）
   とくに注記なし



2019.6.18
checkOfRuleSpecificCoreLine()
  CalcRoute::ReRouteRule69j(route_list_raw, &route_list_tmp);	// 69を適用したものをroute_list_tmpへ
  CalcRoute::ReRouteRule70j(route_list_tmp, &route_list_tmp2);// 70を適用したものをroute_list_tmp2へ
  CalcRoute::CheckOfRule88j(&route_list_tmp2); // 88を適用したものをroute_list_tmpへ
  /* 特定都区市内発着可否判定 */
   chk = CalcRoute::CheckOfRule86(route_list_tmp2, last_flag, &exit, &enter, &cityId);
   if ((chk == 4) || (chk == 0)) {  /* 全駅特定都区市内駅 or 発着とも特定都区市内駅でない場合 */
    /* 未変換 */
    route_list_cooked.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
    return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   }
   route_list_tmp <= route_list_tmp2
   CalcRoute::ReRouteRule86j87j(cityId, chk & ~aply88, exit, enter, &route_list_tmp);
   CalcRoute::CheckOfRule88j(&route_list_tmp); // 88を適用(新大阪発は大阪発に補正)
   CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
   /* ここまで
    * route_list_tmp	70-88-69-86適用
    * route_list_tmp2	70-88-69適用
    * route_list_tmp3	70-88-69-86-69適用
    */
if ((2000 < jsales_km) && ((CalcRoute::InRouteUrban(route_list_raw) != URB_TOKYO) || (2000 < skm))) {
    /* <<<都区市内適用>>> */
    /* 201km <= jsales_km */
    /* enable */
    last_flag &= ~LF_TER_CITY_MASK;
    last_flag |= ((chk & 0x03) << BLF_TER_BEGIN_CITY);	// BLF_TER_BEGIN_CITY, BLF_TER_FIN_CITY
    TRACE("applied for rule86(%d)\n", chk & 0x03);

    // route_list_cooked = route_list_tmp3
    route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());

    BIT_ON(last_flag, BLF_RULE_EN);    // applied rule

    return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
}

/* 101km - 200km : 山手線発着 or 200km以下の都区市内間(名古屋-大阪など)チェック */
rtky = CalcRoute::CheckOfRule87(route_list_tmp2);
if ((3 & rtky) != 0) {
    /* apply to 87 */  /* 都区内に限り最短が100km以下は非適用(基115-2) */
    if ((1000 < jsales_km) && ((CalcRoute::InRouteUrban(route_list_raw) != URB_TOKYO) ||
        (1000 < skm))) {
        /* 山手線内発着 enable */
        if ((MASK(BLF_JRTOKAISTOCK_ENABLE) | MASK(BLF_JRTOKAISTOCK_APPLIED)) !=
            (last_flag & (MASK(BLF_JRTOKAISTOCK_ENABLE) | MASK(BLF_JRTOKAISTOCK_APPLIED)))) {

            last_flag &= ~LF_TER_CITY_MASK;
            last_flag |= ((rtky & 0x03) << BLF_TER_BEGIN_YAMATE);	// BLF_TER_BEGIN_YAMATE, BLF_TER_FIN_YAMATE
            TRACE("applied for rule87\n");
        }
            // route_list_cooked = route_list_tmp3
        route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());

        BIT_ON(last_flag, BLF_RULE_EN);    // applied rule

        return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    }
    sk = 900;	/* 90km */
} else {
    /* can't apply to 87 */
    sk = 1900;	/* 190km */
}

// route_list_tmp4 = route_list_tmp3
route_list_tmp4.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());

/* 発着とも都区市内? */
if ((0x03 & (rtky | chk)) == 3) { /* 名古屋市内-大阪市内など([名]-[阪]、[九]-[福]、[区]-[浜]) */
                        /*  [区]-[区], [名]-[名], [山]-[区], ... */
    for (sk2 = 2000; true; sk2 = 1000) {
        flg = 0;

        /* route_list_tmp = route_list_tmp2 */
        route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
        /* 発駅のみ特定都区市内着経路に変換 */
        CalcRoute::ReRouteRule86j87j(cityId, 1, exit, enter, &route_list_tmp);

        // 69を適用したものをroute_list_tmp3へ
        n = CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
        TRACE("Rule 69(3) applied %dtimes.\n", n);

        /* 発駅のみ都区市内にしても201/101km以上か？ */
        km_raw = CalcRoute::Get_route_distance(last_flag, route_list_tmp3);
        skm = km_raw[0] - km_raw[2];
        if (sk2 < skm) {
            // 発 都区市内有効
            flg = 0x01;
        }

        /* route_list_tmp = route_list_tmp2 */
        route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
        /* 着駅のみ特定都区市内着経路に変換仮適用 */
        CalcRoute::ReRouteRule86j87j(cityId, 2, exit, enter, &route_list_tmp);

        // 69を適用したものをroute_list_tmp3へ
        n = CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
        TRACE("Rule 69(4) applied %dtimes.\n", n);

        /* 着駅のみ都区市内にしても201/101km以上か？ */
        km_raw = CalcRoute::Get_route_distance(last_flag, route_list_tmp3);
        skm = km_raw[0] - km_raw[2];
        if (sk2 < skm) {
            // 着 都区市内有効
            flg |= 0x02;
        }
        if (flg == 0x03) {	/* 発・着とも200km越えだが、都区市内間は200km以下 */
            if (BIT_CHK(last_flag, BLF_MEIHANCITYFLAG)) {
                /* 発のみ都区市内適用 */
                /* route_list_tmp = route_list_tmp2 */
                route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
                /* 発駅のみ特定都区市内着経路に変換 */
                CalcRoute::ReRouteRule86j87j(cityId, 1, exit, enter, &route_list_tmp);

                // 69を適用したものをroute_list_tmp3へ
                n = CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
                TRACE("Rule 69(5) applied %dtimes.\n", n);

                /* 発駅・着駅特定都区市内だが発駅のみ都区市内適用 */
                if (sk == 900) {
                    TRACE("applied for rule87(start)\n");
                    last_flag &= ~LF_TER_CITY_MASK;
                    last_flag |= (MASK(BLF_TER_BEGIN_YAMATE) | MASK(BLF_TER_BEGIN_CITY_OFF));
                } else {
                    TRACE("applied for rule86(start)\n");
                    last_flag &= ~LF_TER_CITY_MASK;
                    last_flag |= (MASK(BLF_TER_BEGIN_CITY) | MASK(BLF_TER_BEGIN_CITY_OFF));
                }
                // route_list_cooked = route_list_tmp3
                route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());
                BIT_ON(last_flag, BLF_RULE_EN);    // applied rule
                return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            } else {
                /* 着のみ都区市内適用 */
                /* 発駅・着駅特定都区市内だが着駅のみ都区市内適用 */
                if (sk == 900) {
                    TRACE("applied for rule87(end)\n");
                    last_flag &= ~LF_TER_CITY_MASK;
                    last_flag |= (MASK(BLF_TER_FIN_YAMATE) | MASK(BLF_TER_FIN_CITY_OFF));
                } else {
                    TRACE("applied for rule86(end)\n");
                    last_flag &= ~LF_TER_CITY_MASK;
                    last_flag |= (MASK(BLF_TER_FIN_CITY) | MASK(BLF_TER_FIN_CITY_OFF));
                }
                // route_list_cooked = route_list_tmp3
                route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());
                BIT_ON(last_flag, BLF_RULE_EN);    // applied rule
                return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            }
        } else if (flg == 0x01) {
            /* route_list_tmp = route_list_tmp2 */
            route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
            /* 発駅のみ特定都区市内着経路に変換 */
            CalcRoute::ReRouteRule86j87j(cityId, 1, exit, enter, &route_list_tmp);

            // 69を適用したものをroute_list_tmp3へ
            n = CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
            TRACE("Rule 69(6) applied %dtimes.\n", n);

            /* 発駅・着駅特定都区市内だが発駅のみ都区市内適用 */
            if (sk == 900) {
                TRACE("applied for rule87(start)\n");
                last_flag &= ~LF_TER_CITY_MASK;
                BIT_ON(last_flag, BLF_TER_BEGIN_YAMATE);
            } else {
                TRACE("applied for rule86(start)\n");
                last_flag &= ~LF_TER_CITY_MASK;
                BIT_ON(last_flag, BLF_TER_BEGIN_CITY);
            }
            // route_list_cooked = route_list_tmp3
            route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());
            BIT_ON(last_flag, BLF_RULE_EN);    // applied rule
            return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        } else if (flg == 0x02) {
            /* 発駅・着駅特定都区市内だが着駅のみ都区市内適用 */
            if (sk == 900) {
                TRACE("applied for rule87(end)\n");
                last_flag &= ~LF_TER_CITY_MASK;
                BIT_ON(last_flag, BLF_TER_FIN_YAMATE);
            } else {
                TRACE("applied for rule86(end)\n");
                last_flag &= ~LF_TER_CITY_MASK;
                BIT_ON(last_flag, BLF_TER_FIN_CITY);
            }
            // route_list_cooked = route_list_tmp3
            route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());
            BIT_ON(last_flag, BLF_RULE_EN);    // applied rule
            return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        }
        /* flg == 0 */
        if ((sk != 900) || (sk2 == 1000)) {
            /* 87無効 or 営業キロ200km越え判定は済 */
            break;
        }
    } /* sk2= 2000, 1000 */
    /* passthru */
} /* ((0x03 & (rtky | chk)) == 3)  名古屋市内-大阪市内など([名]-[阪]、[九]-[福]、[区]-[浜]) */

/* route_list_tmp	x
 * route_list_tmp2	70-88-69適用
 * route_list_tmp3	x
 * route_list_tmp4	70-88-69-86-69適用
 * route_list_cooked 空
 */

/* 未変換 */
TRACE("no applied for rule86/87(jsales_km=%d)\n", jsales_km);

if (sk <= jsales_km) {
        /* 114条適用かチェック */

    if ((0x03 & chk) == 3) {

        route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
        /* 発駅のみ特定都区市内着経路に変換 */
        CalcRoute::ReRouteRule86j87j(cityId, 1, exit, enter, &route_list_tmp);

        // 69を適用したものをroute_list_tmp3へ
        CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
        CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp3);

        route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
        CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp);
        rule114 =					/* 86,87適用前,   86,87適用後 */
                 CalcRoute::CheckOfRule114j(last_flag, route_list_tmp, route_list_tmp3,
                                        0x01 | ((sk2 == 2000) ? 0 : 0x8000));
        if (rule114.fare == 0) {
            route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
            /* 着駅のみ特定都区市内着経路に変換 */
            CalcRoute::ReRouteRule86j87j(cityId, 2, exit, enter, &route_list_tmp);

            // 69を適用したものをroute_list_tmp3へ
            CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
            CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp3);

            route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
            CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp);
            rule114 = CalcRoute::CheckOfRule114j(last_flag, route_list_tmp, route_list_tmp3,
                                           0x02 | ((sk2 == 2000) ? 0 : 0x8000));
        }
    } else {
        route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
        route_list_tmp3.assign(route_list_tmp4.cbegin(), route_list_tmp4.cend());
        CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp);
        CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp3);
        ASSERT(((0x03 & chk) == 1) || ((0x03 & chk) == 2));
        rule114 =
        CalcRoute::CheckOfRule114j(last_flag, route_list_tmp, route_list_tmp3,
                               (chk & 0x03) | ((sk == 1900) ? 0 : 0x8000));
    }
} else {
    ;
}
/* 86-87非適用 */
// route_list_cooked = route_list_tmp2
route_list_cooked.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
return rule114;




<Android>
駅データアクセス部 Java
Android UI Kotlin

<iOS>
駅データアクセス部 C++ Windows版と共有・同一ソース
データアクセス、UI I/F部 Objective-C
UI部 Swift

<Windows>
駅データアクセス部 C++ Windows版と共有・同一ソース
Windows UI C++/MFC
汎用部 C++
SQLite3 I/F C++


2019.5.2 Androidで大都市近郊区間で遠回りし、運賃詳細画面で、特例を適用しないにして計算はして結果も表示するが再メニュー表示がされない不具合がある。
問題はNoRULEフラグがRouteList側にありCalc側に無い点？
AndroidではRouteは毎回構築しなおすのでRuleEnが消えちゃうので。


b#19032701

修正方針
Windowsは修正しない
iOS, androidは修正する。
「最新データ以外のデータベースへ変更すると経路は保存できません。また、保存されている経路はすべてクリアされます」
設定のデータベース変更時にメイン経路をクリアする（警告ダイアログが必要）
Leftview は読み直すようにする。

セットアップでエラー経路を弾く
保存もみんな可能


Android
git diff してDB分けた前提の保存経路のロジックを削除すること

Android 経路読み直し（チケットホルダ）
ActionBarDrawerToggle onDrawerOpened()
  MainActivityのmDrawerFragmentを介して、FolderFragment内のメンバ変数を変更し、
  bool dbChange みたいなの。か、直接 ticketFolder.load()をMainから呼ぶ
 MainはonActivityResultから設定Activityの抜けた後。

Android 経路読み直し（Archive）
 onCreate()で、readParamしている。onCreateは毎回呼ばれているから問題なし？？？

Android 設定切り替え
 ダイアログの表示。いいえだと切り替えキャンセル
 はいだとチケットホルダ読み直し（上記）。


iOS:
viewDidLoadに必ずきて、そこでロードしている

viewDidAppearに画面を閉じたら必ずきてしまう。

LeftViewないのdelegate経由で、MainTableView内のメンバ関数を呼んでLoadしなおすか判断する。
タイミングはLeftViewのviewWillAppearでやる。


iOS 設定ビューから、longTermFuncModeをセットしてprocessDureingIndicatorAnimatingへいく
設定画面->DidApper
closeModalで、db IDXが変更されていたら、vieContextMode=FGD.CONTEXT_ROUTESETUP_VIEW を設定している
viewDidAppear
つまりiOSでは設定ビューでデータソースを切り替えるとメイン経路をスクリプトで再読み込みさせている。
その方法は経路保存ビューの経路変更と同じ処理で行なっている。
注意することとして、設定ビューへ行く前に、メイン経路スクリプトをとっておいて、設定ビューから戻ってきてから
メイン経路スクリプトを作ることなどをしていない。それは設定ビューで既にデータベースが切り替わっており、
設定ビューから帰ってきてから経路スクリプトを作成しても、ぶっ壊れたものが作成されてしまうからである。




b#18122802
八高線 拝島-八王子間をとおる経路は、中央線 立川経由の経路(電車特定区間)の方が安価ならそちらが採用されるべき
成瀬-福生 は八高線経由の方が安い
新横浜-福生 は立川経由の方が安い
成瀬-福生 669(670) 35/36 550
1.換算キロ36kmで幹線適用で¥669(670)
2.立川経由で42km電車特定区間で712(720)
安い方を選択する

新横-福生 918(920) 50/51 ¥799(800)
1.換算キロ51kmで幹線適用で¥972(970)
2.立川経由で56km 電車特定区間適用で918(920)
安い方を選択する

方針
1. 最短経路にする
2. 運賃算出
3. 経路内に八王子と拝島があったら(分岐駅のみ見るで良い)立川経由のルートも作っておき運賃算出(固定キロ足すだけ)
4. 1と3の安い方を選択する


XXXX          XXXX
xxxx  xxxx    xxxx  xxxx
xxxx  拝島     xxxx  八王子
八高線 八王子   八高線 拝島
xxxx xxxx    　XXXX XXXX

　　XXXX          XXXX
xxxx  　xxxx    xxxx  xxxx
xxxx 　 拝島     xxxx  八王子
青梅線   立川   　中央東線 立川
中央東線 八王子 　青梅線 拝島
xxxx xxxx 　   　XXXX XXXX



成瀬-福生は670(669)
新横浜ー福生は920(918)
新横浜ー拝島840(842)

。。。。では、たりなかった。
大船-拝島がダメ
相模線が電車特定ではないため、割高になってしまう。さらに地方交通線。

そうすっと、電車特定区間のnode_listの営業キロを10%減にしたとしてもダメそう。

近郊区間内で、もし、運賃が電車特定でない場合（IS_TKMSP）、電車特定以外のノードを排除して最短経路で検索しなおし、
そちらと比較する。
電車特定以外のノードの抽出には、t_node を拡張する。flagフィールドを追加し、電車区間に1を設定する。
vector<vector<int32_t>> Route::Node_next(int32_t jctId)の関数も修正。
jrdb.xlsに、node シート追加。node_list.txt をもとに作成。node_list.py も修正







TODO:
Android / iOs 結果表示
isAppliedSpecificFare() を"会社線"というキーワードを検索し、結果表示に"(特定区間運賃)"を追加

IC運賃計算経路
も。

-----***!!!***
金山、岐阜
岐阜、美濃太田
美濃太田、多治見
多治見、金山
の、いずれかの駅が連続できたら最初の上記駅または上記駅より前から、
上記駅以外の駅まで(上記駅で終わっていた場合その駅まで)の最短経路を算出して経路を書き換える。
--->採用

春日井 中央西線 多治見 太多線 美濃太田 高山線 岐阜 東海道線 米原 東海道新幹線 名古屋 関西線 四日市
とすると、最短経路は
春日井 中央西線 金山\(中\) 東海道線 米原 東海道新幹線 名古屋 関西線 四日市
となり、名古屋で6の字(P型)経路となり、打ち切られてしまう。この場合、IC運賃も指定経路通りで計算する

四日市 関西線 名古屋 東海道新幹線 米原 東海道線 岐阜 高山線 美濃太田 太多線 多治見 中央西線 春日井


新幹線と御殿場線を除く
新幹線だったら新幹線着駅まで経路作り、同じく新幹線着駅まで最短算出

　　　　四日市
関西線　名古屋
新幹線　米原
東海道線　岐阜
高山線　美濃太田
太多線　多治見
中央西線　春日居
→四日市　名古屋　金山　春日井となって大幅短縮になってしまう


        関ヶ原
東海道線　米原
新幹線　名古屋
東海道線　金山
中央西線　多治見
→関ヶ原　岐阜　美濃太田　多治見　となってしまう


     米原
新幹線　名古屋
東海道線　岐阜
高山線　美濃太田
太多線　多治見
中央西線　塩尻
→　米原 岐阜 美濃太田・・・となってしまう。

　　　名古屋
新感線　米原
東海道線　岐阜
高山線　美濃太田
→ 名古屋　岐阜　美濃太田・・・となってしまう

　　岐阜羽島
新感線　米原
東海道線　岐阜
高山線　美濃太田
→ 岐阜羽島　名古屋　金山　多治見　美濃太田　となってしまう


              国府津
御殿場線 沼津
東海道線 岐阜
高山線   美濃太田
太多線 多治見
中央西線  春日井     金山なら無効(6の字), 塩尻あり

     米原
新幹線 名古屋
東海道線  岐阜
高山線   美濃太田
太多線 多治見        これはこれで新幹線 名古屋がとっぱらえてok

      四日市
関西線 名古屋
東海道線 岐阜
高山線 美濃太田
太多線 多治見
中央西線 金山
東海道線 三河安城
新幹線 三島
東海道線 富士      四日市 三河安城 最短

　　　春日井
中央西線  金山
東海道線 岐阜
高山線　蘇原

　　　姫
太多線　美濃太田
高山線　岐阜
東海道線　稲沢

　　　下呂
高山線　美濃太田
太多線　多治見
中央西線　金山



経路のはじめと終わりで、
- 御殿場線が１経路めだったらその次の駅から。
- ２経路めが新幹線だったら

　　　　熱海
新幹線 静岡
東海道線 草薙

　　　　沼津
東海道線 三島
新幹線 静岡
東海道線 金山
中央西線

この場合、
熱海 東海道線 草薙
沼津 静岡

になってしまわないよう、
    国母
身延線 富士
東海道線 三島
新幹線 名古屋
東海道線 金山
中央西線 多治見
->ムリ 三島省かれる



東京 千葉 総武線
千葉 蘇我 外房線

山科 近江塩津 湖西線

日暮里 赤羽 東北線
赤羽 大宮 東北線

JR東海のICカード運賃
JR東海圏内だけを単純に最短経路計算にしたら、草薙-静岡の新幹線逆戻りや、御殿場線経由まで最短経路に計算されてしまう副作用がある。
なので、69条と同じ方法で経路付け替えして計算
-> 難しいので却下

経路のはじめと終わりで、
- 御殿場線が１経路めだったらその次の駅から。
- ２経路めが新幹線だったら

　　　　熱海
新幹線 静岡
東海道線 草薙

　　　　沼津
東海道線 三島
新幹線 静岡
東海道線 金山
中央西線

この場合、
熱海 東海道線 草薙
沼津 静岡

になってしまわないよう、



尾張一宮 東海道線 金山 中央西線 多治見
木曽川 東海道線 岐阜 高山線 美濃太田 太田線 多治見

これだと、中間駅が変換してくれない？？？？

reCalcFareForOptiomizeRoute での不具合

蒲田ー松本のように最短経路ではなく86条適用で東京からの方が安い場合があるので、
この場合,東京-松本の最短経路で計算する
神田からぐるっと回って品川でも都区内ー都区内の場合、神田ー品川の最安で。

最短経路で国府津ー沼津は東海道線が最短なのでそっちで計算してしまうが、それはJR東。

大回りして、都区内->都区内（実は神田ー秋葉原）や、都区内ー＞横浜市内 実は蒲田ー川崎だったら？

新潟が近郊区間になっていない？

JR東海のみが効いていない？

川崎 大きく回って 蒲田
蒲田 大きく回って 神田
蒲田 松本
三鷹 大きく回って新宿 が都区市内になってはあかん。
両方 86条だったら 指定の駅で最短経路算出 86条から戻るかもしれない
片方のみ86条だったら、中心駅で最短経路算出

御殿場線 国府津 沼津が最短経路(東海道線経由)をIC運賃として表示してしまっている
御殿場 熱海も同様
熱海 新幹線 静岡 在来線 草薙 も同様になってしまうが？
-> ダメとする。





2019.2.3
last_flag周りをいつか修正する

aggregate_fare_info
や、
calc_fareあたりで、FARE_INFOとCalcRouteの間で渡しあったり、いじりあったりするのはおかしい。
Main側で持つべきObjectもなんとかしたい。
Object構成をいちから見直すべき。

--

大都市近郊区間

拝島 八高線 八王子





-------<<< 運賃計算処理概要 >>>>-------
FARE_INFO fare_info = calcFare()   // from APP Interface.
                                   // 全ての必要な情報みんなFARE_INFOに格納されてくる
                                   /* 86, 87, 69, 70条 114条適用かチェック */
{
 /* no_rule flag により以下をやるか否か */
 rule114 = checkOfRuleSpecificCoreLine();	// route_list_raw -> route_list_cooked

 fare_info.calc_fare(&last_flag, route_list_raw, route_list_cooked);
   fare_info.aggregate_fare_info()
   fare_info.CheckIsJRTokai() JR東海のみ?
   adjust_km = FARE_INFO::CheckAndApplyRule43_2j(routeList_cooked);
   fare_info.retr_fare() 運賃計算を適用。フラグ見て、fare_infoのfareにセットする

 return fare_info;
}
-------

株主優待適用条件

calc_fare()
 aggregate_fare_inf(), CheckIsJRTokai()の呼び出し後、

		TRACE("@@@:isNotCityterminalWoTokai()=%d, isCityterminalWoTokai()=%d, %d\n", isNotCityterminalWoTokai(), isCityterminalWoTokai(), *last_flag & LF_TER_CITY_MASK);
		TRACE("@@@ en=%d, aply=%d rule=%d norule=%d\n", BIT_CHK(*last_flag, BLF_JRTOKAISTOCK_ENABLE),
			BIT_CHK(*last_flag, BLF_JRTOKAISTOCK_APPLIED),
			BIT_CHK(*last_flag, BLF_NO_RULE), BIT_CHK(*last_flag, BLF_RULE_EN));

 品川　東海道新幹線　熱海		1 0 0  		1 0 0 0
 品川　東海道新幹線 名古屋  	0 1 24576 	1 0 0 1	特例適用中		提S
							1 0 0		0 0 1 0 特例非適用		*
							1 0 16384	1 1 0 0 株主優待適用	S*
 品川 東海道新幹線　三河安城 	0 1 8192	1 0 0 1                提S
							1 0 0		0 0 1 0               *
							1 0 0		1 1 0 0               S*
 品川 東海道新幹線　三島		0 1 32768	1 0 0 1 [山]          提S
							1 0 0		0 0 1 0               *
							1 0 0		1 1 0 0               S*
 品川 東海道新幹線　新横浜		1 0 0		1 0 0 0               *
 三島　東海道新幹線　静岡		1 0 0		0 0 0 0               *
 小田原　東海道新幹線　熱海		1 0 0		0 0 0 0               *
上野　東北新幹線 盛岡			-------
海尻 小海線 小海				------


S: 切り替え有効
提：株主優待適用可能表示
*: 株主優待適用



2018/3/21

小田原 熱海
0 1 0　　　0(1:NG)

品川 名古屋
0 1 0　　　1(0:NG)       最後の提案は1であるべきなのだが0でNG
0 1 1     0 優待券行使（OK)
0 0 1     0 OK

大高　川崎
0 1 0	0  メニュー提案してくるのがダメ

大高 神戸
0 1 0   0  メニュー提案してくるのがダメ

品川 四日市
0 1 0	1(0)NG
0 1 1	0 OK 優待券行使

桑園 岩見沢 長万部
0 1 0 	0 OK メニューで提案してくるのでNG

桑園 岩見沢
0 1 0 	0(1)NG

新谷 内子
0 0 0   0(1)NG

富士 富士宮
0 0 0	0(1)NG

岐阜羽島 米原
0 0 0   0(1)NG

大崎 品川 熱海
0 1 0	0(1)NG

1 0 0 あり得ない？
1 0 1　あり得ない
>>>>>
1 1 0 1 x


!!!!!!!!!!!!!!!!!!

!!!!!!!!!



city
BLF_JRTOKAISTOCK_ENABLE
BLF_JRTOKAISTOCK_APPLIED
suggestion



非適用だと都区内になっていないので株主優待表示なのに提案している
株主行使適用が効いていない。


tstring CalcRoute::showFare()
  FARE_INFO CalcRoute::calcFare()
    bool CalcRoute::checkJrEastTokai() /* JR東海以外 and JR東日本で新幹線でない場合false */    remove
     -> BLF_JREAST_IN_TOKAI on/off                                                        remove
        BLF_JRTOKAI_STOCK_APPLY off                                                       remove
    CalcRoute.checkOfRuleSpecificCoreLine()
        CalcRoute::CheckOfRule86()                                   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv <-- remove
 	        else if ((city_no_s != 0) && (city_no_s != CITYNO_NAGOYA) && BIT_CHK(last_flag, BLF_JREAST_IN_TOKAI)) {
	        	/* "JR東海株主優待券使用"指定のときは適用条件可否適用 */
	        	r |= 0x80000000; // BIT_ON(last_flag, BLF_JRTOKAI_STOCK_APPLY); // for UI　　＝＝＝＞「提案可能フラグ」
	        	if (BIT_CHK(last_flag, BLF_JRTOKAI_STOCK)) { /* by user */   ======>「提案適用フラグ」
	        		city_no_s = 0;
	        	}
	        }
	    CheckOfRule86()の直下
	    if (BIT_CHK(chk, 31)) {
	    	BIT_ON(last_flag, BLF_JRTOKAI_STOCK_APPLY); // for UI        setFareOption で適用時ONする　　　＝＝＝＞「提案可能フラグ」
	    }
	    else {
	    	BIT_OFF(last_flag, BLF_JRTOKAI_STOCK_APPLY); // for UI                                      ＝＝＝＞「提案可能フラグ」
	    }
	    ======>
		checkJrEastTokai()は削除

		/* 山手線内発着 enable */
		if ((MASK(BLF_JREAST_IN_TOKAI) | MASK(BLF_JRTOKAISTOCK_APPLIED)) !=
			(last_flag & (MASK(BLF_JREAST_IN_TOKAI) | MASK(BLF_JRTOKAISTOCK_APPLIED)))) {

			last_flag &= ~LF_TER_CITY_MASK;
			last_flag |= ((rtky & 0x03) << BLF_TER_BEGIN_YAMATE);	// BLF_TER_BEGIN_YAMATE, BLF_TER_FIN_YAMATE
			TRACE("applied for rule87\n");
		}


    FARE_INFO::calc_fare()
      FARE_INFO::aggregate_fare_info()
        FARE_INFO::getDistanceEx() ********************* companymask
      ======>
	  aggregate_fare_inf() call 直後に
	    if checkJrEastTokai()をリネームした処理が有効  -> checkIsJRTokai
	      if CheckOfRule86で設定したフラグ「提案可能フラグ」が無効の場合、
		    companynmaskをJR東海単独に
		   else
			「提案可能フラグ」をON
		    if UI指定の「株主適用フラグ」がON
			  companynmaskをJR東海単独に.
　          else
              nothing


  fare_info.getFareStockDiscount()
    FARE_INFO::getStockDiscountCompany()
	    if ((JR_GROUP_MASK & companymask) == (1 << (JR_EAST - 1))) {
	    	return JR_EAST;
	    }
		:
        /＊ [名]以外の[都][区]内または[横]が適用されていたらJR東海ではない＊
        /* Route::CheckOfRule86() */
        if (((STATION_ID_AS_CITYNO < beginTerminalId) &&
             (CITYNO_NAGOYA != (beginTerminalId - STATION_ID_AS_CITYNO)))|
             ((STATION_ID_AS_CITYNO < endTerminalId) &&
              (CITYNO_NAGOYA != (endTerminalId - STATION_ID_AS_CITYNO)))) {
          return 0;


// showFare()の最後
if (BIT_CHK(last_flag, BLF_JREAST_IN_TOKAI) &&
    (fare_info.getStockDiscountCompany() != JR_CENTRAL)) {
    sResult += _T("\r\nJR東海株主優待券使用オプション選択可");
}
=====>
  「提案可能フラグ」？　かつ ！「提案適用フラグ」
  　　株主優待選択可の表示

＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
提案可能フラグ
  BLF_JRTOKAISTOCK_ENABLE  (BLF_JRTOKAI_STOCK_APPLY)
  東海道新幹線で[区][山][浜][京][阪]が適用する場面でセットされる
  JR東海株主優待適用・非適用選択メニューが有効となる
提案適用フラグ
  BLF_JRTOKAISTOCK_APPLIED （BLF_JRTOKAI_STOCK）
  UI側からユーザが指定する
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
品川 小田原 Sになるが、Aでよし
使用行使しても効かず





他のフラグはトル

companymaskをみて株優判定判断

RouteList::getFareOption()
	// JR東海株主 有無 bit 4-5
	if (BIT_CHK(last_flag, BLF_JREAST_IN_TOKAI)) {                    ===>「提案可能フラグ」
		if (BIT_CHK(last_flag, BLF_JRTOKAI_STOCK)) {                  ===>「提案適用フラグ」
			rc |= (1 << 9);     // 0x200 : Enable
		}
		else {
			rc |= (1 << 8);		// default: Disable 0x100
		}
	}

CalcRoute::getFareOption()
	// JR東海株主 有無 bit 4-5
	if ((0 != (0x300 & rc)) /*&& BIT_CHK(last_flag, BLF_NO_RULE)*/) {
		if (!BIT_CHK(last_flag, BLF_JRTOKAI_STOCK_APPLY)) {          ＝＝＝＞「提案可能フラグ」
			rc &= ~0x300;
		}
	}

RouteList::setFareOption()
	/* JR東海株主適用有無 */
	if (0 != (FAREOPT_AVAIL_APPLIED_JRTOKAI_STOCK & availbit)) {
		if (FAREOPT_JRTOKAI_STOCK_APPLIED == (FAREOPT_JRTOKAI_STOCK_APPLIED & cooked)) {
			BIT_ON(last_flag,  BLF_JRTOKAI_STOCK);    /* 適用 */     　＝＝＝＞「提案適用フラグ」
		} else {
			BIT_OFF(last_flag,  BLF_JRTOKAI_STOCK);   /* 非適用 */　　　＝＝＝＞「提案適用フラグ」
		}
	}


BLF_JREAST_IN_TOKAI -> S to U     -> Is Suggestion -> ＝＝＝＞ remove
BLF_JRTOKAI_STOCK -> U to S       ->　　　　　　　　　　　 ＝＝＝＞「提案可能フラグ」BLF_JRTOKAISTOCK_ENABLE
BLF_JRTOKAI_STOCK_APPLY -> Inner  -> Suggestion Enable　＝＝＝＞「提案適用フラグ」BLF_JRTOKAISTOCK_APPLIED

・・・・・・・・・・・・



経路の全区間で、
発着ともJR東海駅ではないか、
発駅がJR東海でも境界駅でもない
着駅がJR東海でも境界駅でもない
とFalse



//////////////////////////////////////////////////////////////////////
showFare()の戻り値

uint32_t RouteList::getFareOption()
計算結果より指定可能なフラグオプションの情報を返す
 bit6 on: start only
 bit7   : empty
 bit1:0 : 大阪環状線1回通過
 bit5:4 : 特例適用されていて非適用指定されている
 bit4   : 特例適用されていて非適用されていない(規定)
 bit1   : 発 都区市内発着(名阪)
 bit0   : 着 都区市内発着(名阪)

uint32_t CalcRoute::getFareOption()
 	uint32_t rc = RouteList::getFareOption();
　　 return if empty or start

void RouteList::setFareOption(uint16_t cooked, uint16_t availbit)
Rule適用か
京阪線着駅指定単駅か市内駅か

JR東海　
フラグ一つ返す（上記のbit
小倉博多の設定　




2014-12-11
iOS側で使用するメソッドリスト

- RouteDataController:
    initWithAssign(イニシャライザ) route.assign(route&)

- ResultView(entity)
  routeScript
  showFare
  autoRoute
  addRoute
  resetStartStation resetRoute removeAll()
  lastStationId lastRouteItemStationId route->routeList().back().stationId
  startStationId startStationId startStationId()
  calcFare

- MainView(edit route)
  getRouteCount
  removeTail
  calcFare
  resetStartStation
  reverseRoute
  autoRoute
  setupRoute
  startStationId
  getRouteItem
  addRoute
  lastLineId
  routeScript



2014-11-3
sflg 13-15 reserve
のうち13を使用 「BCBULARB:新幹線利用も含む近郊区間フラグ」として使用
米原、京都、新大阪、相生、西明石
新神戸-新大阪、新神戸-西明石はNGなので、新大阪-西明石はNGとなるようにしなければならない。
発駅、着駅のみで判定すると、東海道新幹線と山陽新幹線でわかれているから良いものの、新大阪-西明石はNGなのOKとなる。


2013-12-9
-―――――――――――
GIT コミット後のログ
-――――――――――
2014-2-6
DB新幹線、西小倉、吉塚を分岐駅に指定

2014-2-3
showFare()不完全経路を追加

2014-1-26
 albdp.cpp - getBsrjctSpType() query invalid statement '%d% -> '?'
 getBsrjctSpType() I/F変更AttrOfStationOnLineLine()で得たlflgの下位8ビットは
 sflgのものであるから正しくない。
 TODO: test_result.txt 結果の確認
 TODO: jb21はadd()ではxではない。showFareでYETフラグ見て未完成であることを
 しめさなければならない。
 TODO: 長岡廻りの実装

2014-1-22
  フラグビット23-16がOffにしており、新幹線乗換フラグ(b19-20)がロストしてしまっていた。
  AttrOfStationOnLineLine()修正で対応

2014-1-3　コミット

2013-12-20
Excel修正
	b29ONの定義
	最終カラム(20カラム)に、路線1分岐駅1路線2乗換駅を定義。それぞれ、jctsp_line_id1, jctsp_station_id1, jctsp_line_id2, jctsp_station_id2 となる
	                                                                  上越線　　　　　　浦佐              未定義          宮内
	を上記の順番に'/'で区切り、並べる
	jctsp_line_id2はb31の日田彦山線ケースでのみ使用なので未定義

	鹿児島線-西小倉は///だけ入れる
	20カラムが空または、!なら未定義それ以外は、b29をONとする


DB修正
DBスクリプト修正
	t_jctspcl.type列追加
	b29追加
	b29のt_jcpspclのレコード追加(レコード構造変更修正も含む)

DBのb29:BSRJCTSP_B

alpdb.cpp:
b30:BSRNOTYETの実装
b31:BSRJCTHORD の定義追加
フローと箇条書き仕様書の実装(宮内-長岡廻りと、福岡県廻りの2件の計3件)

2013-12-19 (commit complete)
フラグの定義を大幅に仕様変更
小倉-西小倉回り
宮内-長岡回りの仕様追加と修正

-――――――――――


lflg
31 分岐特例駅		x
30 常に0、1はDB読エラー	o
29 69条区間開始駅	o Query_a69listで使用
28 69条区間開始駅	o 同上 読出では不要
27 新幹線		o 新幹線乗換判定で使用
26 新幹線		o
25 新幹線		o
24 -
23 会社線		△
22 新幹線内分岐駅	・
21 会社境界駅
20-17 69で使用DB読時は0
16-13 新幹線並行在来ID GetHZLine()で使用(新幹線のみ)DB読み込み時は不要
0-12 station.cflg
add()でセット時は、0x1fffでMaskするため0-12までのみ使用


- 88条
CheckOfRule88j()

(a)
　　　　　新大阪
東海道線　(神戸)
山陽線    XXXX
 :          :

*XXXXは、山陽線、神戸から姫路までの距離以上にあること
新大阪、東海道線、山陽線をチェックすれば、(神戸)は神戸でしかありえない。
|
V
　　　　　大阪
東海道線　(神戸)
山陽線    XXXX
 :          :
に置き換え

(b)
 :
          XXXX
山陽線    (神戸)
東海道線　新大阪

*XXXXは、山陽線、神戸から姫路までの距離以上にあること
新大阪、東海道線、山陽線をチェックすれば、(神戸)は神戸でしかありえない。
|
V
 :
          XXXX
山陽線    (神戸)
東海道線　大阪
に置き換え

(c)
            大阪
(東海道線)  新大阪
山陽新幹線  YYYY
 :
*大阪、新大阪、山陽新幹線をチェックすれば、(東海道線)は自明
YYYYは山陽新幹線に新大阪からの距離が姫路以遠であること
|
v
            新大阪
山陽新幹線  YYYY
に置き換え
ではなく、
            大阪
東海道線    神戸       *1
山陽線      西明石     *1
山陽新幹線  YYYY
に置き換え

*1に追加フラグとして経由表示しないを追加
他に計算除外をフラグも設ける

(d)
 :
?????        YYYY
山陽新幹線   新大阪
(東海道線)   大阪

*大阪、新大阪、山陽新幹線をチェックすれば、(東海道線)は自明
YYYYは山陽新幹線に新大阪からの距離が姫路以遠であること
|
V
 :
?????        YYYY
山陽新幹線   新大阪
ではなく、
            大阪
東海道線    神戸       *1
山陽線      西明石     *1
山陽新幹線  YYYY
に置き換え

*1に追加フラグとして経由表示しないを追加
他に計算除外をフラグも設ける？





- 運賃計算構成


c: show_route() をshow_fare()の中にいれる

showFare:
	checkOfRuleSpecificCoreLine(void); // route_list_raw -> route_list_cooked
	86,87適用の発着表示
	fare_info.calc_fare(route_list_raw);
	fare_info.fare に金額



showFare() の処理要約
	- checkOfRuleSpecificCoreLine() /* 86, 87, 69, 70条 114条適用かチェック */
	- 114条適用されていたら1行目にその場合の運賃額を表示する
	- route_list_cookedが空でないと規則適用と判断し都区市内発着表示を
	     - route_list_cookedに対してcalc_fare()
	- route_list_cookedが空の場合規則非適用と判断し
	     - route_list_rawに対してcalc_fare()
	- fare_infoの運賃を表示
	-
	-
	-
下関-岩国
経由：山陽線
営業キロ： 182.0 km 計算キロ： 182.0 km
運賃：\3,260     \2,600[2割引] \3,260[周割] \6,520[往復] \1,950[4割引]
有効日数：   2日

下関-岩国
経由：山陽線<櫛ヶ浜>岩徳線
営業キロ： 182.0 km 計算キロ： 182.0 km
運賃：\3,260     \2,600[2割引] \3,260[周割] \6,520[往復] \1,950[4割引]
有効日数：   2日

fare_info.calc_fare:
	FARE_INFO::aggregate_fare_info(ite->lineId, station_id1, ite->stationId)) {
		FARE_INFO::CheckSpecficFarePass(line_id, station_id1, station_id2);	// 特別加算区間（同一会社発着)
		FARE_INFO::Fare_company(station_id1, station_id2);			// 会社線
	FARE_INFO::days_ticket(this->sales_km);						// JRのみの営業キロで86,87適用後の距離で計算すべき
	FARE_INFO::SpecficFareLine(routeList.front().stationId, routeList.back().stationId);	// 特例運賃

	* {は、ノード毎 インデント内は各ノードに対していおこなわれる.



route.checkOfRuleSpecificCoreLine:  86、87条、69条判定＆経路算出 showFare()の最初に呼ばれる
	Route::CheckOfRule86(route_list_raw, &exit, &enter, &cityId);
	Route::reRouteRule86j87j(cityId, chk, exit, enter);
		Route::SpecificCoreAreaFirstTransferStationBy(exit.lineId, IDENT1(cityId));
		Route::Retrieve_SpecificCoreStation(IDENT1(cityId));
		Route::SpecificCoreAreaFirstTransferStationBy(enter.lineId, IDENT2(cityId));
		Route::Retrieve_SpecificCoreStation(IDENT2(cityId));
	Route::ReRouteRule70j(route_list_raw, &route_list_cooked)
	Route::reRouteRule69j(route_tmp);			/* 69条適用(route_tmp->route_list_cooked) */
	Route::CheckOfRule87(route_list_raw);
	Route::CheckOfRule88j(&route_list_cooked);
	Route::CheckOfRule114j(route_list_raw, route_list_cooked, rtky & 0x03 | 0x8000);
	Route::reRouteRule86j87j(cityId, 2, exit, enter);
	Route::reRouteRule69j(route_tmp);			/* 69条適用(route_tmp->route_list_cooked) */
	Route::reRouteRule86j87j(cityId, 1, exit, enter);
	Route::reRouteRule69j(route_tmp);			/* 69条適用(route_tmp->route_list_cooked) */
	Route::CheckOfRule88j(&route_list_cooked);
	Route::CheckOfRule114j(route_list_raw, route_list_cooked, chk & 0x03);







----------------------------------------------------------------

// 往復割引 1割引き 端数切り捨て 10190 → 9170

#if 0
利用区間に新下関～博多間を含む場合は、新幹線と在来線とでは運賃が異なります。
この例の場合の運賃計算は次のとおりです。
ゆきは新幹線利用で本州内幹線の運賃を適用し、運算計算キロは1179.3kmで13,440円。
片道1割引で12,090円。かえりは在来線利用で博多～東京間の運賃計算キロは1179.3kmで
「本州3社内の幹線の普通運賃表」を適用した13,440円にJR九州利用分（博多～下関間79km）の
加算額150円を加え、13,590円。片道1割引で12,230円になります。
往復割引運賃は12,090円＋12,230円＝24,320円です。


#endif

// デバック----------------------------------------------------------------

#if 0	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  計算キロ220km～で、都区市内適用されていない場合、114条を試みる？
					Route::CheckOfRule114j(route, route_new, rtky & 0x03 | 0x8000)

	if (1900 < sales_km) {
		Route::CheckOfRule114j(route, route_new, rtky & 0x03 | 0x8000);
	}

	長津田-国母の例
	国母は横浜から200


...............
viewDidAppear   viewContextMode をセット
actionSelectProcFrom   longTermFuncMode
processDuringIndicatorAnimating


doneTerminal segue
 viewContextMode = .ROUTESETUP_VIEW;
 self.routeScript = routeViewCtrl.selectRouteString;
viewDidAppear
 　longTermFuncMode = .SETUPROUTE;
  長い処理を仕掛ける　引数にScriptを渡しているがメンバ変数にしているので意味なし。相手も拾えるって。 longTermFuncModeもそうだし。

長い処理：processDuringIndicatorAnimating
  longTermFuncModeで分岐 setup_route()する。あとよろ
