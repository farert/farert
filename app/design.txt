

大都市近郊区間適用　19.8.1

  近郊 86 新幹 最短 日数 近郊         x   特例 特例非適用時
 1 T   T  F : n    1   Y(最短可能)  ac  y    ad
 2 T   T  T : n    1   Y(最短可能)  ac  y    ad
 3 T   F  F : Y    1   Y           b   n
 4 T   F  T : n    *   n           -   n
 5 F   -  - : n    *   n           -   n

 最短は復活
 [近郊区間内ですので最短経路の運賃で利用可能です(途中下車不可、有効日数当日限り)] -a
 は、近郊区間で特例非適用時に表示していた。
[近郊区間内ですので最安運賃の経路にしました(途中下車不可、有効日数当日限り)] -b

[または、「特例非適用」で単駅発着が選択可能です.] - c
[または、「特例適用」で特定都区市内発着か選択可能です.] - d

最短算出するのは,     近郊 and !86 and !bullet  3
有効日数を1にするのは, 近郊 and (86 || !bullet)  1,2,3
showFare()でメッセージa: 近郊 and 86
         メッセージb: 近郊 and !86 and !bullet
         メッセージc: 86 is Tのとき
calc_route.BLF_NO_RULE -a

適用
NO_RULEがONでも86,87を無効にしているのか、69を無効にしているのか、70を無効にしているのかわからん。
NO_RULEがONでも
adは、わからへんのでは？86、87が適用できる実力かはNO_RULEがONではわからなくなってしまう。

蒲田 東海道線 川崎 南武線 立川 中央東線 塩尻 篠ノ井線 松本
は、神田経由で計算されていたが、今度は、南武線経由となる。






1=前谷地, 2=柳津

?1 line_id1
?2 stid1
?3 stid2
?4 brtid1
?5 brtid2
sales_kmは?4<?5
?2と?3は入れ違いあり


1 a b 2 : a-b 全線内なのでそのまま brt_sales_km -= (a-b)
1 a 2 b : a-2                                    brt_sales_km -= (a-2)
1 2 a b : 0　　通ってないので変換なし brt_sales_km -= 0
a 1 2 b :  brt_sales_km -= (1-2)
a b 1 2 : 0
a 1 b 2 : brt_sales_km -= (1-b)

-> brtexp.py

2019.07.01
会社線営業キロ

0 < total_jr_calc_km && total_jr_sales_km == total_jr_calc_km 計算キロあり
getCompanySalesKm() = sales_km - total_jr_sales_km;

brt kmは、total_jr_sales_km - brt_sales_km

brt_sales_kmは作成する(会社線はなかったがBRTは作成する)
total_jr_sales_km はBRT営業キロを含む？
total_jr_calc_km は？

int32_t company_fare;				/* 会社線料金 */
int32_t company_fare_ac_discount;	/* 学割用会社線割引額 */
int32_t company_fare_child;			/* 会社線小児運賃 */

データ構造(FARE_INFO)
int32_t brt_fare
int32_t brt_sales_km
int32_t brt_calc_km
int32_t brt_discount_fare
を追加する


BRT運賃計算処理概要
aggregate_fare_jr()で、
 line_idがBRTならBRTの営業キロを加算する。
(brt_sales_kmの更新)

こここで、前谷地-柳津の除外処理もする。＞しない
// 路線内の駅1〜駅2が、駅3〜駅4内に含まれるか？重なる部分の営業キロ、計算キロを返す
// -----
//   == 　　==を返す
// --
//    == 　0を返す
// ----
//   ====  ==の距離を返す
// ----
// ====    ====の距離を返す
// line_id [in] 路線
// station_id1 [in] 検査する駅1
// station_id2 [in] 検査する駅2
// station_id3 [in] 検査する駅3
// station_id4 [in] 検査する駅4
int32_t inlineOnline(int32_t line_id, int32_t station_id2, int32_t station_id2, int32_t station_id3, int32_t station_id4);
 ->テーブルから引数
 前谷地-柳津なら0以外の値が返ってくるので、sales_km, calc_kmに加算する

t_brtsp

retr_fare()のなかの先頭で,経路でまわし. brt_sales_km = 0ならなんにもしない。
retr_fare

for line_id, station_id1, station_id2 in route_list:
  if not BRT line:
    flg = 0
    for stid1, stid2, type in query(t_brtsp where line_id):
      n = inlineOnline(lid, station_id1, station_id2, stid1, stid2)  # 既存inStation()の検査対象駅が1つでなく2つにしたもの(AND条件)
      if n != 2:
        discount = false; // brt乗り継ぎ割引は無効
      endif
      flg = 1
    next
    if flg == 0: //テーブルレコードなし
       discount = false;  // brt乗り継ぎ割引は無効
    endif
   endif
//

BRTのみ
BRT+JR非割引区間
BRT+JR非割引区間
会社線区間は関係ない。

aggregate_fare_infoループないですべておこなうか？独立して行うか？
BRTのみは、brt_sales_km != 0 && total_sales_km == 0





DB Scriptで、柳津-前谷地の路線IDを落とす。＞辞め

前谷地-気仙沼 の扱い
前谷地-気仙沼は、BRTでも鉄道線の扱い。
経路から前谷地-気仙沼のキロを追加する。
BRT線内に、前谷地-気仙沼線のマイナス分を得る。
-----
  ======
なら、重なる部分のキロを返すクエリを作成する。


km = diff_overlap_route(line_id, station_id1, station_id2)






2019.06.30
jrsutezo.docx 改訂
lflg.18 を空きとする(会社線フラグ廃止)会社線はline_idで見分けられることとと認め不要になった

2019.6.27
やりたいこと。
InStation2(station_id1, station_id2, line_id, r_station_id1, r_station_id2)
  line_idのr_station_id1からr_station_id2の範囲内にstation_id1~station_id2の全駅が含まれているか？

  →要らない？
  2回inStation()を実行すれば良いだけ。

  石巻-福田町、陸前原ノ町-仙台
  は、
  石巻-仙台 とした際には、石巻は前者に含まれるが、後者には含まれない。

  もしやりたい場合でも、
  select count(*)
  	from t_lines
  	where line_id=?1
  	and station_id in (select station_id from t_lines
                        and (lflg&(1<<31))=0
                      	and sales_km>=
                      			(select min(sales_km)
                      			from t_lines
                      			where line_id=?1
                      			and (station_id=?4 or
                      				 station_id=?5))
                      	and sales_km<=
                      			(select max(sales_km)
                      			from t_lines
                      			where line_id=?1
                      			and (station_id=?4 or
                      				 station_id=?5))
                       )
  	and (lflg&(1<<31))=0
  	and sales_km>=
  			(select min(sales_km)
  			from t_lines
  			where line_id=?1
  			and (station_id=?2 or
  				 station_id=?3))
  	and sales_km<=
  			(select max(sales_km)
  			from t_lines
  			where line_id=?1
  			and (station_id=?2 or
  				 station_id=?3));
でいける。





aggregate_fare_info


志津川ー新庄は？ えきすぱあとは全鉄道線として計算している。2590円
              否、新庄-柳津(2,270) + 柳津-志津川(320) = 2590
              ()はFarert16.03で計算)

BRTを実装しました。
路線名にBRTと含まれている場合はBRTとなります。
BRTは営業キロは通算しますが運賃計算は会社線と同様打ち切って計算します（通過前後のJR線は通算します）。
柳津-前谷地は鉄道も並走しますがこの区間のBRT線は鉄道線として扱われます、
BRTと鉄道線の乗り換え範囲は以下にしめす鉄道線は¥100割引されます
https://www.jreast.co.jp/railway/train/brt/guide.html
BRTと鉄道線、会社線の利用制限はBRT=JRグループ鉄道線としています(現状と同じく)。
以上です。ルールが異なるということでしたら直ちに修正対応しますのでご一報ください。




2019.6.21
路線IDをIDで新幹線、会社線、BRTかを分けられるように
いままでしようとしてなぜそれができなかったのか？？？？
Pythonスクリプト変えてみてBranch BRTで試してみる。



2019.6.20
- BRT対応
  路線名はBRTとする。Pythonスクリプトで、路線IDを+10000 する
  大船渡線 盛-気仙沼間は、大船渡線(BRT)とする。既存の大船渡線は一ノ関-気仙沼間に短縮する
  気仙沼線(BRT)を追加。気仙沼-前谷地 とする。既存の気仙沼線は、柳津-前谷地に短縮する。（気仙沼線 柳津-前谷地は並走区間）

 　並走区間(前谷地-柳津)は鉄道と乗り継いでも通算する。

  路線IDを以下とする。
  #新幹線 0x1000~
  #会社線 0x2000~
  #BRT   0x3000~

  t_brtsp を追加 BRT-鉄道乗り継ぎで、¥100をマイナスする区間を定義（駅1、駅2、路線, type）
  type=0は乗り継ぎ割引期間
      =1はBRT線だがBRT線とはしない区間

- エクスポート／インポート対応(iOSとAndroidのみ)
経路保存画面でインポートとエクスポートのアイコンボタンを設置する。
 - インポートボタン
  「クリップボードの内容を取り込みますか？」（はい・いいえ）
   リストの前段に追加する。全体のMAXに溢れたら（最大XX件までですので、XX件は漏れました）と表示
   「XX件取り込みました. 青色の文字の経路です。保存ボタンを押すまでは保存はされません」
   青字にする

 - エクスポートボタン
  「経路をクリップボードへエクスポートしますか？クリップボードは破棄されます」（はい、いいえ）
   とくに注記なし



2019.6.18
checkOfRuleSpecificCoreLine()
  CalcRoute::ReRouteRule69j(route_list_raw, &route_list_tmp);	// 69を適用したものをroute_list_tmpへ
  CalcRoute::ReRouteRule70j(route_list_tmp, &route_list_tmp2);// 70を適用したものをroute_list_tmp2へ
  CalcRoute::CheckOfRule88j(&route_list_tmp2); // 88を適用したものをroute_list_tmpへ
  /* 特定都区市内発着可否判定 */
   chk = CalcRoute::CheckOfRule86(route_list_tmp2, last_flag, &exit, &enter, &cityId);
   if ((chk == 4) || (chk == 0)) {  /* 全駅特定都区市内駅 or 発着とも特定都区市内駅でない場合 */
    /* 未変換 */
    route_list_cooked.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
    return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   }
   route_list_tmp <= route_list_tmp2
   CalcRoute::ReRouteRule86j87j(cityId, chk & ~aply88, exit, enter, &route_list_tmp);
   CalcRoute::CheckOfRule88j(&route_list_tmp); // 88を適用(新大阪発は大阪発に補正)
   CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
   /* ここまで
    * route_list_tmp	70-88-69-86適用
    * route_list_tmp2	70-88-69適用
    * route_list_tmp3	70-88-69-86-69適用
    */
if ((2000 < jsales_km) && ((CalcRoute::InRouteUrban(route_list_raw) != URB_TOKYO) || (2000 < skm))) {
    /* <<<都区市内適用>>> */
    /* 201km <= jsales_km */
    /* enable */
    last_flag &= ~LF_TER_CITY_MASK;
    last_flag |= ((chk & 0x03) << BLF_TER_BEGIN_CITY);	// BLF_TER_BEGIN_CITY, BLF_TER_FIN_CITY
    TRACE("applied for rule86(%d)\n", chk & 0x03);

    // route_list_cooked = route_list_tmp3
    route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());

    BIT_ON(last_flag, BLF_RULE_EN);    // applied rule

    return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
}

/* 101km - 200km : 山手線発着 or 200km以下の都区市内間(名古屋-大阪など)チェック */
rtky = CalcRoute::CheckOfRule87(route_list_tmp2);
if ((3 & rtky) != 0) {
    /* apply to 87 */  /* 都区内に限り最短が100km以下は非適用(基115-2) */
    if ((1000 < jsales_km) && ((CalcRoute::InRouteUrban(route_list_raw) != URB_TOKYO) ||
        (1000 < skm))) {
        /* 山手線内発着 enable */
        if ((MASK(BLF_JRTOKAISTOCK_ENABLE) | MASK(BLF_JRTOKAISTOCK_APPLIED)) !=
            (last_flag & (MASK(BLF_JRTOKAISTOCK_ENABLE) | MASK(BLF_JRTOKAISTOCK_APPLIED)))) {

            last_flag &= ~LF_TER_CITY_MASK;
            last_flag |= ((rtky & 0x03) << BLF_TER_BEGIN_YAMATE);	// BLF_TER_BEGIN_YAMATE, BLF_TER_FIN_YAMATE
            TRACE("applied for rule87\n");
        }
            // route_list_cooked = route_list_tmp3
        route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());

        BIT_ON(last_flag, BLF_RULE_EN);    // applied rule

        return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    }
    sk = 900;	/* 90km */
} else {
    /* can't apply to 87 */
    sk = 1900;	/* 190km */
}

// route_list_tmp4 = route_list_tmp3
route_list_tmp4.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());

/* 発着とも都区市内? */
if ((0x03 & (rtky | chk)) == 3) { /* 名古屋市内-大阪市内など([名]-[阪]、[九]-[福]、[区]-[浜]) */
                        /*  [区]-[区], [名]-[名], [山]-[区], ... */
    for (sk2 = 2000; true; sk2 = 1000) {
        flg = 0;

        /* route_list_tmp = route_list_tmp2 */
        route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
        /* 発駅のみ特定都区市内着経路に変換 */
        CalcRoute::ReRouteRule86j87j(cityId, 1, exit, enter, &route_list_tmp);

        // 69を適用したものをroute_list_tmp3へ
        n = CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
        TRACE("Rule 69(3) applied %dtimes.\n", n);

        /* 発駅のみ都区市内にしても201/101km以上か？ */
        km_raw = CalcRoute::Get_route_distance(last_flag, route_list_tmp3);
        skm = km_raw[0] - km_raw[2];
        if (sk2 < skm) {
            // 発 都区市内有効
            flg = 0x01;
        }

        /* route_list_tmp = route_list_tmp2 */
        route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
        /* 着駅のみ特定都区市内着経路に変換仮適用 */
        CalcRoute::ReRouteRule86j87j(cityId, 2, exit, enter, &route_list_tmp);

        // 69を適用したものをroute_list_tmp3へ
        n = CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
        TRACE("Rule 69(4) applied %dtimes.\n", n);

        /* 着駅のみ都区市内にしても201/101km以上か？ */
        km_raw = CalcRoute::Get_route_distance(last_flag, route_list_tmp3);
        skm = km_raw[0] - km_raw[2];
        if (sk2 < skm) {
            // 着 都区市内有効
            flg |= 0x02;
        }
        if (flg == 0x03) {	/* 発・着とも200km越えだが、都区市内間は200km以下 */
            if (BIT_CHK(last_flag, BLF_MEIHANCITYFLAG)) {
                /* 発のみ都区市内適用 */
                /* route_list_tmp = route_list_tmp2 */
                route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
                /* 発駅のみ特定都区市内着経路に変換 */
                CalcRoute::ReRouteRule86j87j(cityId, 1, exit, enter, &route_list_tmp);

                // 69を適用したものをroute_list_tmp3へ
                n = CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
                TRACE("Rule 69(5) applied %dtimes.\n", n);

                /* 発駅・着駅特定都区市内だが発駅のみ都区市内適用 */
                if (sk == 900) {
                    TRACE("applied for rule87(start)\n");
                    last_flag &= ~LF_TER_CITY_MASK;
                    last_flag |= (MASK(BLF_TER_BEGIN_YAMATE) | MASK(BLF_TER_BEGIN_CITY_OFF));
                } else {
                    TRACE("applied for rule86(start)\n");
                    last_flag &= ~LF_TER_CITY_MASK;
                    last_flag |= (MASK(BLF_TER_BEGIN_CITY) | MASK(BLF_TER_BEGIN_CITY_OFF));
                }
                // route_list_cooked = route_list_tmp3
                route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());
                BIT_ON(last_flag, BLF_RULE_EN);    // applied rule
                return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            } else {
                /* 着のみ都区市内適用 */
                /* 発駅・着駅特定都区市内だが着駅のみ都区市内適用 */
                if (sk == 900) {
                    TRACE("applied for rule87(end)\n");
                    last_flag &= ~LF_TER_CITY_MASK;
                    last_flag |= (MASK(BLF_TER_FIN_YAMATE) | MASK(BLF_TER_FIN_CITY_OFF));
                } else {
                    TRACE("applied for rule86(end)\n");
                    last_flag &= ~LF_TER_CITY_MASK;
                    last_flag |= (MASK(BLF_TER_FIN_CITY) | MASK(BLF_TER_FIN_CITY_OFF));
                }
                // route_list_cooked = route_list_tmp3
                route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());
                BIT_ON(last_flag, BLF_RULE_EN);    // applied rule
                return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            }
        } else if (flg == 0x01) {
            /* route_list_tmp = route_list_tmp2 */
            route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
            /* 発駅のみ特定都区市内着経路に変換 */
            CalcRoute::ReRouteRule86j87j(cityId, 1, exit, enter, &route_list_tmp);

            // 69を適用したものをroute_list_tmp3へ
            n = CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
            TRACE("Rule 69(6) applied %dtimes.\n", n);

            /* 発駅・着駅特定都区市内だが発駅のみ都区市内適用 */
            if (sk == 900) {
                TRACE("applied for rule87(start)\n");
                last_flag &= ~LF_TER_CITY_MASK;
                BIT_ON(last_flag, BLF_TER_BEGIN_YAMATE);
            } else {
                TRACE("applied for rule86(start)\n");
                last_flag &= ~LF_TER_CITY_MASK;
                BIT_ON(last_flag, BLF_TER_BEGIN_CITY);
            }
            // route_list_cooked = route_list_tmp3
            route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());
            BIT_ON(last_flag, BLF_RULE_EN);    // applied rule
            return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        } else if (flg == 0x02) {
            /* 発駅・着駅特定都区市内だが着駅のみ都区市内適用 */
            if (sk == 900) {
                TRACE("applied for rule87(end)\n");
                last_flag &= ~LF_TER_CITY_MASK;
                BIT_ON(last_flag, BLF_TER_FIN_YAMATE);
            } else {
                TRACE("applied for rule86(end)\n");
                last_flag &= ~LF_TER_CITY_MASK;
                BIT_ON(last_flag, BLF_TER_FIN_CITY);
            }
            // route_list_cooked = route_list_tmp3
            route_list_cooked.assign(route_list_tmp3.cbegin(), route_list_tmp3.cend());
            BIT_ON(last_flag, BLF_RULE_EN);    // applied rule
            return rule114;			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        }
        /* flg == 0 */
        if ((sk != 900) || (sk2 == 1000)) {
            /* 87無効 or 営業キロ200km越え判定は済 */
            break;
        }
    } /* sk2= 2000, 1000 */
    /* passthru */
} /* ((0x03 & (rtky | chk)) == 3)  名古屋市内-大阪市内など([名]-[阪]、[九]-[福]、[区]-[浜]) */

/* route_list_tmp	x
 * route_list_tmp2	70-88-69適用
 * route_list_tmp3	x
 * route_list_tmp4	70-88-69-86-69適用
 * route_list_cooked 空
 */

/* 未変換 */
TRACE("no applied for rule86/87(jsales_km=%d)\n", jsales_km);

if (sk <= jsales_km) {
        /* 114条適用かチェック */

    if ((0x03 & chk) == 3) {

        route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
        /* 発駅のみ特定都区市内着経路に変換 */
        CalcRoute::ReRouteRule86j87j(cityId, 1, exit, enter, &route_list_tmp);

        // 69を適用したものをroute_list_tmp3へ
        CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
        CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp3);

        route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
        CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp);
        rule114 =					/* 86,87適用前,   86,87適用後 */
                 CalcRoute::CheckOfRule114j(last_flag, route_list_tmp, route_list_tmp3,
                                        0x01 | ((sk2 == 2000) ? 0 : 0x8000));
        if (rule114.fare == 0) {
            route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
            /* 着駅のみ特定都区市内着経路に変換 */
            CalcRoute::ReRouteRule86j87j(cityId, 2, exit, enter, &route_list_tmp);

            // 69を適用したものをroute_list_tmp3へ
            CalcRoute::ReRouteRule69j(route_list_tmp, &route_list_tmp3);	/* 69条適用(route_list_tmp->route_list_tmp3) */
            CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp3);

            route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
            CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp);
            rule114 = CalcRoute::CheckOfRule114j(last_flag, route_list_tmp, route_list_tmp3,
                                           0x02 | ((sk2 == 2000) ? 0 : 0x8000));
        }
    } else {
        route_list_tmp.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
        route_list_tmp3.assign(route_list_tmp4.cbegin(), route_list_tmp4.cend());
        CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp);
        CalcRoute::ConvertShinkansen2ZairaiFor114Judge(&route_list_tmp3);
        ASSERT(((0x03 & chk) == 1) || ((0x03 & chk) == 2));
        rule114 =
        CalcRoute::CheckOfRule114j(last_flag, route_list_tmp, route_list_tmp3,
                               (chk & 0x03) | ((sk == 1900) ? 0 : 0x8000));
    }
} else {
    ;
}
/* 86-87非適用 */
// route_list_cooked = route_list_tmp2
route_list_cooked.assign(route_list_tmp2.cbegin(), route_list_tmp2.cend());
return rule114;




<Android>
駅データアクセス部 Java
Android UI Kotlin

<iOS>
駅データアクセス部 C++ Windows版と共有・同一ソース
データアクセス、UI I/F部 Objective-C
UI部 Swift

<Windows>
駅データアクセス部 C++ Windows版と共有・同一ソース
Windows UI C++/MFC
汎用部 C++
SQLite3 I/F C++


2019.5.2 Androidで大都市近郊区間で遠回りし、運賃詳細画面で、特例を適用しないにして計算はして結果も表示するが再メニュー表示がされない不具合がある。
問題はNoRULEフラグがRouteList側にありCalc側に無い点？
AndroidではRouteは毎回構築しなおすのでRuleEnが消えちゃうので。


b#19032701

修正方針
Windowsは修正しない
iOS, androidは修正する。
「最新データ以外のデータベースへ変更すると経路は保存できません。また、保存されている経路はすべてクリアされます」
設定のデータベース変更時にメイン経路をクリアする（警告ダイアログが必要）
Leftview は読み直すようにする。

セットアップでエラー経路を弾く
保存もみんな可能


Android
git diff してDB分けた前提の保存経路のロジックを削除すること

Android 経路読み直し（チケットホルダ）
ActionBarDrawerToggle onDrawerOpened()
  MainActivityのmDrawerFragmentを介して、FolderFragment内のメンバ変数を変更し、
  bool dbChange みたいなの。か、直接 ticketFolder.load()をMainから呼ぶ
 MainはonActivityResultから設定Activityの抜けた後。

Android 経路読み直し（Archive）
 onCreate()で、readParamしている。onCreateは毎回呼ばれているから問題なし？？？

Android 設定切り替え
 ダイアログの表示。いいえだと切り替えキャンセル
 はいだとチケットホルダ読み直し（上記）。


iOS:
viewDidLoadに必ずきて、そこでロードしている

viewDidAppearに画面を閉じたら必ずきてしまう。

LeftViewないのdelegate経由で、MainTableView内のメンバ関数を呼んでLoadしなおすか判断する。
タイミングはLeftViewのviewWillAppearでやる。


iOS 設定ビューから、longTermFuncModeをセットしてprocessDureingIndicatorAnimatingへいく
設定画面->DidApper
closeModalで、db IDXが変更されていたら、vieContextMode=FGD.CONTEXT_ROUTESETUP_VIEW を設定している
viewDidAppear
つまりiOSでは設定ビューでデータソースを切り替えるとメイン経路をスクリプトで再読み込みさせている。
その方法は経路保存ビューの経路変更と同じ処理で行なっている。
注意することとして、設定ビューへ行く前に、メイン経路スクリプトをとっておいて、設定ビューから戻ってきてから
メイン経路スクリプトを作ることなどをしていない。それは設定ビューで既にデータベースが切り替わっており、
設定ビューから帰ってきてから経路スクリプトを作成しても、ぶっ壊れたものが作成されてしまうからである。



成瀬-福生は670(669)
新横浜ー福生は920(918)
新横浜ー拝島840(842)

TODO:
Android / iOs 結果表示
isAppliedSpecificFare() を"会社線"というキーワードを検索し、結果表示に"(特定区間運賃)"を追加

IC運賃計算経路
も。

-----***!!!***
金山、岐阜
岐阜、美濃太田
美濃太田、多治見
多治見、金山
の、いずれかの駅が連続できたら最初の上記駅または上記駅より前から、
上記駅以外の駅まで(上記駅で終わっていた場合その駅まで)の最短経路を算出して経路を書き換える。
--->採用

春日井 中央西線 多治見 太多線 美濃太田 高山線 岐阜 東海道線 米原 東海道新幹線 名古屋 関西線 四日市
とすると、最短経路は
春日井 中央西線 金山\(中\) 東海道線 米原 東海道新幹線 名古屋 関西線 四日市
となり、名古屋で6の字(P型)経路となり、打ち切られてしまう。この場合、IC運賃も指定経路通りで計算する

四日市 関西線 名古屋 東海道新幹線 米原 東海道線 岐阜 高山線 美濃太田 太多線 多治見 中央西線 春日井


新幹線と御殿場線を除く
新幹線だったら新幹線着駅まで経路作り、同じく新幹線着駅まで最短算出

　　　　四日市
関西線　名古屋
新幹線　米原
東海道線　岐阜
高山線　美濃太田
太多線　多治見
中央西線　春日居
→四日市　名古屋　金山　春日井となって大幅短縮になってしまう


        関ヶ原
東海道線　米原
新幹線　名古屋
東海道線　金山
中央西線　多治見
→関ヶ原　岐阜　美濃太田　多治見　となってしまう


     米原
新幹線　名古屋
東海道線　岐阜
高山線　美濃太田
太多線　多治見
中央西線　塩尻
→　米原 岐阜 美濃太田・・・となってしまう。

　　　名古屋
新感線　米原
東海道線　岐阜
高山線　美濃太田
→ 名古屋　岐阜　美濃太田・・・となってしまう

　　岐阜羽島
新感線　米原
東海道線　岐阜
高山線　美濃太田
→ 岐阜羽島　名古屋　金山　多治見　美濃太田　となってしまう


              国府津
御殿場線 沼津
東海道線 岐阜
高山線   美濃太田
太多線 多治見
中央西線  春日井     金山なら無効(6の字), 塩尻あり

     米原
新幹線 名古屋
東海道線  岐阜
高山線   美濃太田
太多線 多治見        これはこれで新幹線 名古屋がとっぱらえてok

      四日市
関西線 名古屋
東海道線 岐阜
高山線 美濃太田
太多線 多治見
中央西線 金山
東海道線 三河安城
新幹線 三島
東海道線 富士      四日市 三河安城 最短

　　　春日井
中央西線  金山
東海道線 岐阜
高山線　蘇原

　　　姫
太多線　美濃太田
高山線　岐阜
東海道線　稲沢

　　　下呂
高山線　美濃太田
太多線　多治見
中央西線　金山



経路のはじめと終わりで、
- 御殿場線が１経路めだったらその次の駅から。
- ２経路めが新幹線だったら

　　　　熱海
新幹線 静岡
東海道線 草薙

　　　　沼津
東海道線 三島
新幹線 静岡
東海道線 金山
中央西線

この場合、
熱海 東海道線 草薙
沼津 静岡

になってしまわないよう、
    国母
身延線 富士
東海道線 三島
新幹線 名古屋
東海道線 金山
中央西線 多治見
->ムリ 三島省かれる



東京 千葉 総武線
千葉 蘇我 外房線

山科 近江塩津 湖西線

日暮里 赤羽 東北線
赤羽 大宮 東北線

JR東海のICカード運賃
JR東海圏内だけを単純に最短経路計算にしたら、草薙-静岡の新幹線逆戻りや、御殿場線経由まで最短経路に計算されてしまう副作用がある。
なので、69条と同じ方法で経路付け替えして計算
-> 難しいので却下

経路のはじめと終わりで、
- 御殿場線が１経路めだったらその次の駅から。
- ２経路めが新幹線だったら

　　　　熱海
新幹線 静岡
東海道線 草薙

　　　　沼津
東海道線 三島
新幹線 静岡
東海道線 金山
中央西線

この場合、
熱海 東海道線 草薙
沼津 静岡

になってしまわないよう、



尾張一宮 東海道線 金山 中央西線 多治見
木曽川 東海道線 岐阜 高山線 美濃太田 太田線 多治見

これだと、中間駅が変換してくれない？？？？

reCalcFareForOptiomizeRoute での不具合

蒲田ー松本のように最短経路ではなく86条適用で東京からの方が安い場合があるので、
この場合,東京-松本の最短経路で計算する
神田からぐるっと回って品川でも都区内ー都区内の場合、神田ー品川の最安で。

最短経路で国府津ー沼津は東海道線が最短なのでそっちで計算してしまうが、それはJR東。

大回りして、都区内->都区内（実は神田ー秋葉原）や、都区内ー＞横浜市内 実は蒲田ー川崎だったら？

新潟が近郊区間になっていない？

JR東海のみが効いていない？

川崎 大きく回って 蒲田
蒲田 大きく回って 神田
蒲田 松本
三鷹 大きく回って新宿 が都区市内になってはあかん。
両方 86条だったら 指定の駅で最短経路算出 86条から戻るかもしれない
片方のみ86条だったら、中心駅で最短経路算出

御殿場線 国府津 沼津が最短経路(東海道線経由)をIC運賃として表示してしまっている
御殿場 熱海も同様
熱海 新幹線 静岡 在来線 草薙 も同様になってしまうが？
-> ダメとする。





2019.2.3
last_flag周りをいつか修正する

aggregate_fare_info
や、
calc_fareあたりで、FARE_INFOとCalcRouteの間で渡しあったり、いじりあったりするのはおかしい。
Main側で持つべきObjectもなんとかしたい。
Object構成をいちから見直すべき。

--

大都市近郊区間

拝島 八高線 八王子





-------<<< 運賃計算処理概要 >>>>-------
FARE_INFO fare_info = calcFare()   // from APP Interface.
                                   // 全ての必要な情報みんなFARE_INFOに格納されてくる
                                   /* 86, 87, 69, 70条 114条適用かチェック */
{
 /* no_rule flag により以下をやるか否か */
 rule114 = checkOfRuleSpecificCoreLine();	// route_list_raw -> route_list_cooked

 fare_info.calc_fare(&last_flag, route_list_raw, route_list_cooked);
   fare_info.aggregate_fare_info()
   fare_info.CheckIsJRTokai() JR東海のみ?
   adjust_km = FARE_INFO::CheckAndApplyRule43_2j(routeList_cooked);
   fare_info.retr_fare() 運賃計算を適用。フラグ見て、fare_infoのfareにセットする

 return fare_info;
}
-------

株主優待適用条件

calc_fare()
 aggregate_fare_inf(), CheckIsJRTokai()の呼び出し後、

		TRACE("@@@:isNotCityterminalWoTokai()=%d, isCityterminalWoTokai()=%d, %d\n", isNotCityterminalWoTokai(), isCityterminalWoTokai(), *last_flag & LF_TER_CITY_MASK);
		TRACE("@@@ en=%d, aply=%d rule=%d norule=%d\n", BIT_CHK(*last_flag, BLF_JRTOKAISTOCK_ENABLE),
			BIT_CHK(*last_flag, BLF_JRTOKAISTOCK_APPLIED),
			BIT_CHK(*last_flag, BLF_NO_RULE), BIT_CHK(*last_flag, BLF_RULE_EN));

 品川　東海道新幹線　熱海		1 0 0  		1 0 0 0
 品川　東海道新幹線 名古屋  	0 1 24576 	1 0 0 1	特例適用中		提S
							1 0 0		0 0 1 0 特例非適用		*
							1 0 16384	1 1 0 0 株主優待適用	S*
 品川 東海道新幹線　三河安城 	0 1 8192	1 0 0 1                提S
							1 0 0		0 0 1 0               *
							1 0 0		1 1 0 0               S*
 品川 東海道新幹線　三島		0 1 32768	1 0 0 1 [山]          提S
							1 0 0		0 0 1 0               *
							1 0 0		1 1 0 0               S*
 品川 東海道新幹線　新横浜		1 0 0		1 0 0 0               *
 三島　東海道新幹線　静岡		1 0 0		0 0 0 0               *
 小田原　東海道新幹線　熱海		1 0 0		0 0 0 0               *
上野　東北新幹線 盛岡			-------
海尻 小海線 小海				------


S: 切り替え有効
提：株主優待適用可能表示
*: 株主優待適用



2018/3/21

小田原 熱海
0 1 0　　　0(1:NG)

品川 名古屋
0 1 0　　　1(0:NG)       最後の提案は1であるべきなのだが0でNG
0 1 1     0 優待券行使（OK)
0 0 1     0 OK

大高　川崎
0 1 0	0  メニュー提案してくるのがダメ

大高 神戸
0 1 0   0  メニュー提案してくるのがダメ

品川 四日市
0 1 0	1(0)NG
0 1 1	0 OK 優待券行使

桑園 岩見沢 長万部
0 1 0 	0 OK メニューで提案してくるのでNG

桑園 岩見沢
0 1 0 	0(1)NG

新谷 内子
0 0 0   0(1)NG

富士 富士宮
0 0 0	0(1)NG

岐阜羽島 米原
0 0 0   0(1)NG

大崎 品川 熱海
0 1 0	0(1)NG

1 0 0 あり得ない？
1 0 1　あり得ない
>>>>>
1 1 0 1 x


!!!!!!!!!!!!!!!!!!

!!!!!!!!!



city
BLF_JRTOKAISTOCK_ENABLE
BLF_JRTOKAISTOCK_APPLIED
suggestion



非適用だと都区内になっていないので株主優待表示なのに提案している
株主行使適用が効いていない。


tstring CalcRoute::showFare()
  FARE_INFO CalcRoute::calcFare()
    bool CalcRoute::checkJrEastTokai() /* JR東海以外 and JR東日本で新幹線でない場合false */    remove
     -> BLF_JREAST_IN_TOKAI on/off                                                        remove
        BLF_JRTOKAI_STOCK_APPLY off                                                       remove
    CalcRoute.checkOfRuleSpecificCoreLine()
        CalcRoute::CheckOfRule86()                                   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv <-- remove
 	        else if ((city_no_s != 0) && (city_no_s != CITYNO_NAGOYA) && BIT_CHK(last_flag, BLF_JREAST_IN_TOKAI)) {
	        	/* "JR東海株主優待券使用"指定のときは適用条件可否適用 */
	        	r |= 0x80000000; // BIT_ON(last_flag, BLF_JRTOKAI_STOCK_APPLY); // for UI　　＝＝＝＞「提案可能フラグ」
	        	if (BIT_CHK(last_flag, BLF_JRTOKAI_STOCK)) { /* by user */   ======>「提案適用フラグ」
	        		city_no_s = 0;
	        	}
	        }
	    CheckOfRule86()の直下
	    if (BIT_CHK(chk, 31)) {
	    	BIT_ON(last_flag, BLF_JRTOKAI_STOCK_APPLY); // for UI        setFareOption で適用時ONする　　　＝＝＝＞「提案可能フラグ」
	    }
	    else {
	    	BIT_OFF(last_flag, BLF_JRTOKAI_STOCK_APPLY); // for UI                                      ＝＝＝＞「提案可能フラグ」
	    }
	    ======>
		checkJrEastTokai()は削除

		/* 山手線内発着 enable */
		if ((MASK(BLF_JREAST_IN_TOKAI) | MASK(BLF_JRTOKAISTOCK_APPLIED)) !=
			(last_flag & (MASK(BLF_JREAST_IN_TOKAI) | MASK(BLF_JRTOKAISTOCK_APPLIED)))) {

			last_flag &= ~LF_TER_CITY_MASK;
			last_flag |= ((rtky & 0x03) << BLF_TER_BEGIN_YAMATE);	// BLF_TER_BEGIN_YAMATE, BLF_TER_FIN_YAMATE
			TRACE("applied for rule87\n");
		}


    FARE_INFO::calc_fare()
      FARE_INFO::aggregate_fare_info()
        FARE_INFO::getDistanceEx() ********************* companymask
      ======>
	  aggregate_fare_inf() call 直後に
	    if checkJrEastTokai()をリネームした処理が有効  -> checkIsJRTokai
	      if CheckOfRule86で設定したフラグ「提案可能フラグ」が無効の場合、
		    companynmaskをJR東海単独に
		   else
			「提案可能フラグ」をON
		    if UI指定の「株主適用フラグ」がON
			  companynmaskをJR東海単独に.
　          else
              nothing


  fare_info.getFareStockDiscount()
    FARE_INFO::getStockDiscountCompany()
	    if ((JR_GROUP_MASK & companymask) == (1 << (JR_EAST - 1))) {
	    	return JR_EAST;
	    }
		:
        /＊ [名]以外の[都][区]内または[横]が適用されていたらJR東海ではない＊
        /* Route::CheckOfRule86() */
        if (((STATION_ID_AS_CITYNO < beginTerminalId) &&
             (CITYNO_NAGOYA != (beginTerminalId - STATION_ID_AS_CITYNO)))|
             ((STATION_ID_AS_CITYNO < endTerminalId) &&
              (CITYNO_NAGOYA != (endTerminalId - STATION_ID_AS_CITYNO)))) {
          return 0;


// showFare()の最後
if (BIT_CHK(last_flag, BLF_JREAST_IN_TOKAI) &&
    (fare_info.getStockDiscountCompany() != JR_CENTRAL)) {
    sResult += _T("\r\nJR東海株主優待券使用オプション選択可");
}
=====>
  「提案可能フラグ」？　かつ ！「提案適用フラグ」
  　　株主優待選択可の表示

＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
提案可能フラグ
  BLF_JRTOKAISTOCK_ENABLE  (BLF_JRTOKAI_STOCK_APPLY)
  東海道新幹線で[区][山][浜][京][阪]が適用する場面でセットされる
  JR東海株主優待適用・非適用選択メニューが有効となる
提案適用フラグ
  BLF_JRTOKAISTOCK_APPLIED （BLF_JRTOKAI_STOCK）
  UI側からユーザが指定する
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
品川 小田原 Sになるが、Aでよし
使用行使しても効かず





他のフラグはトル

companymaskをみて株優判定判断

RouteList::getFareOption()
	// JR東海株主 有無 bit 4-5
	if (BIT_CHK(last_flag, BLF_JREAST_IN_TOKAI)) {                    ===>「提案可能フラグ」
		if (BIT_CHK(last_flag, BLF_JRTOKAI_STOCK)) {                  ===>「提案適用フラグ」
			rc |= (1 << 9);     // 0x200 : Enable
		}
		else {
			rc |= (1 << 8);		// default: Disable 0x100
		}
	}

CalcRoute::getFareOption()
	// JR東海株主 有無 bit 4-5
	if ((0 != (0x300 & rc)) /*&& BIT_CHK(last_flag, BLF_NO_RULE)*/) {
		if (!BIT_CHK(last_flag, BLF_JRTOKAI_STOCK_APPLY)) {          ＝＝＝＞「提案可能フラグ」
			rc &= ~0x300;
		}
	}

RouteList::setFareOption()
	/* JR東海株主適用有無 */
	if (0 != (FAREOPT_AVAIL_APPLIED_JRTOKAI_STOCK & availbit)) {
		if (FAREOPT_JRTOKAI_STOCK_APPLIED == (FAREOPT_JRTOKAI_STOCK_APPLIED & cooked)) {
			BIT_ON(last_flag,  BLF_JRTOKAI_STOCK);    /* 適用 */     　＝＝＝＞「提案適用フラグ」
		} else {
			BIT_OFF(last_flag,  BLF_JRTOKAI_STOCK);   /* 非適用 */　　　＝＝＝＞「提案適用フラグ」
		}
	}


BLF_JREAST_IN_TOKAI -> S to U     -> Is Suggestion -> ＝＝＝＞ remove
BLF_JRTOKAI_STOCK -> U to S       ->　　　　　　　　　　　 ＝＝＝＞「提案可能フラグ」BLF_JRTOKAISTOCK_ENABLE
BLF_JRTOKAI_STOCK_APPLY -> Inner  -> Suggestion Enable　＝＝＝＞「提案適用フラグ」BLF_JRTOKAISTOCK_APPLIED

・・・・・・・・・・・・



経路の全区間で、
発着ともJR東海駅ではないか、
発駅がJR東海でも境界駅でもない
着駅がJR東海でも境界駅でもない
とFalse



//////////////////////////////////////////////////////////////////////
showFare()の戻り値

uint32_t RouteList::getFareOption()
計算結果より指定可能なフラグオプションの情報を返す
 bit6 on: start only
 bit7   : empty
 bit1:0 : 大阪環状線1回通過
 bit5:4 : 特例適用されていて非適用指定されている
 bit4   : 特例適用されていて非適用されていない(規定)
 bit1   : 発 都区市内発着(名阪)
 bit0   : 着 都区市内発着(名阪)

uint32_t CalcRoute::getFareOption()
 	uint32_t rc = RouteList::getFareOption();
　　 return if empty or start

void RouteList::setFareOption(uint16_t cooked, uint16_t availbit)
Rule適用か
京阪線着駅指定単駅か市内駅か

JR東海　
フラグ一つ返す（上記のbit
小倉博多の設定　




2014-12-11
iOS側で使用するメソッドリスト

- RouteDataController:
    initWithAssign(イニシャライザ) route.assign(route&)

- ResultView(entity)
  routeScript
  showFare
  autoRoute
  addRoute
  resetStartStation resetRoute removeAll()
  lastStationId lastRouteItemStationId route->routeList().back().stationId
  startStationId startStationId startStationId()
  calcFare

- MainView(edit route)
  getRouteCount
  removeTail
  calcFare
  resetStartStation
  reverseRoute
  autoRoute
  setupRoute
  startStationId
  getRouteItem
  addRoute
  lastLineId
  routeScript



2014-11-3
sflg 13-15 reserve
のうち13を使用 「BCBULARB:新幹線利用も含む近郊区間フラグ」として使用
米原、京都、新大阪、相生、西明石
新神戸-新大阪、新神戸-西明石はNGなので、新大阪-西明石はNGとなるようにしなければならない。
発駅、着駅のみで判定すると、東海道新幹線と山陽新幹線でわかれているから良いものの、新大阪-西明石はNGなのOKとなる。


2013-12-9
-―――――――――――
GIT コミット後のログ
-――――――――――
2014-2-6
DB新幹線、西小倉、吉塚を分岐駅に指定

2014-2-3
showFare()不完全経路を追加

2014-1-26
 albdp.cpp - getBsrjctSpType() query invalid statement '%d% -> '?'
 getBsrjctSpType() I/F変更AttrOfStationOnLineLine()で得たlflgの下位8ビットは
 sflgのものであるから正しくない。
 TODO: test_result.txt 結果の確認
 TODO: jb21はadd()ではxではない。showFareでYETフラグ見て未完成であることを
 しめさなければならない。
 TODO: 長岡廻りの実装

2014-1-22
  フラグビット23-16がOffにしており、新幹線乗換フラグ(b19-20)がロストしてしまっていた。
  AttrOfStationOnLineLine()修正で対応

2014-1-3　コミット

2013-12-20
Excel修正
	b29ONの定義
	最終カラム(20カラム)に、路線1分岐駅1路線2乗換駅を定義。それぞれ、jctsp_line_id1, jctsp_station_id1, jctsp_line_id2, jctsp_station_id2 となる
	                                                                  上越線　　　　　　浦佐              未定義          宮内
	を上記の順番に'/'で区切り、並べる
	jctsp_line_id2はb31の日田彦山線ケースでのみ使用なので未定義

	鹿児島線-西小倉は///だけ入れる
	20カラムが空または、!なら未定義それ以外は、b29をONとする


DB修正
DBスクリプト修正
	t_jctspcl.type列追加
	b29追加
	b29のt_jcpspclのレコード追加(レコード構造変更修正も含む)

DBのb29:BSRJCTSP_B

alpdb.cpp:
b30:BSRNOTYETの実装
b31:BSRJCTHORD の定義追加
フローと箇条書き仕様書の実装(宮内-長岡廻りと、福岡県廻りの2件の計3件)

2013-12-19 (commit complete)
フラグの定義を大幅に仕様変更
小倉-西小倉回り
宮内-長岡回りの仕様追加と修正

-――――――――――


lflg
31 分岐特例駅		x
30 常に0、1はDB読エラー	o
29 69条区間開始駅	o Query_a69listで使用
28 69条区間開始駅	o 同上 読出では不要
27 新幹線		o 新幹線乗換判定で使用
26 新幹線		o
25 新幹線		o
24 -
23 会社線		△
22 新幹線内分岐駅	・
21 会社境界駅
20-17 69で使用DB読時は0
16-13 新幹線並行在来ID GetHZLine()で使用(新幹線のみ)DB読み込み時は不要
0-12 station.cflg
add()でセット時は、0x1fffでMaskするため0-12までのみ使用


- 88条
CheckOfRule88j()

(a)
　　　　　新大阪
東海道線　(神戸)
山陽線    XXXX
 :          :

*XXXXは、山陽線、神戸から姫路までの距離以上にあること
新大阪、東海道線、山陽線をチェックすれば、(神戸)は神戸でしかありえない。
|
V
　　　　　大阪
東海道線　(神戸)
山陽線    XXXX
 :          :
に置き換え

(b)
 :
          XXXX
山陽線    (神戸)
東海道線　新大阪

*XXXXは、山陽線、神戸から姫路までの距離以上にあること
新大阪、東海道線、山陽線をチェックすれば、(神戸)は神戸でしかありえない。
|
V
 :
          XXXX
山陽線    (神戸)
東海道線　大阪
に置き換え

(c)
            大阪
(東海道線)  新大阪
山陽新幹線  YYYY
 :
*大阪、新大阪、山陽新幹線をチェックすれば、(東海道線)は自明
YYYYは山陽新幹線に新大阪からの距離が姫路以遠であること
|
v
            新大阪
山陽新幹線  YYYY
に置き換え
ではなく、
            大阪
東海道線    神戸       *1
山陽線      西明石     *1
山陽新幹線  YYYY
に置き換え

*1に追加フラグとして経由表示しないを追加
他に計算除外をフラグも設ける

(d)
 :
?????        YYYY
山陽新幹線   新大阪
(東海道線)   大阪

*大阪、新大阪、山陽新幹線をチェックすれば、(東海道線)は自明
YYYYは山陽新幹線に新大阪からの距離が姫路以遠であること
|
V
 :
?????        YYYY
山陽新幹線   新大阪
ではなく、
            大阪
東海道線    神戸       *1
山陽線      西明石     *1
山陽新幹線  YYYY
に置き換え

*1に追加フラグとして経由表示しないを追加
他に計算除外をフラグも設ける？





- 運賃計算構成


c: show_route() をshow_fare()の中にいれる

showFare:
	checkOfRuleSpecificCoreLine(void); // route_list_raw -> route_list_cooked
	86,87適用の発着表示
	fare_info.calc_fare(route_list_raw);
	fare_info.fare に金額



showFare() の処理要約
	- checkOfRuleSpecificCoreLine() /* 86, 87, 69, 70条 114条適用かチェック */
	- 114条適用されていたら1行目にその場合の運賃額を表示する
	- route_list_cookedが空でないと規則適用と判断し都区市内発着表示を
	     - route_list_cookedに対してcalc_fare()
	- route_list_cookedが空の場合規則非適用と判断し
	     - route_list_rawに対してcalc_fare()
	- fare_infoの運賃を表示
	-
	-
	-
下関-岩国
経由：山陽線
営業キロ： 182.0 km 計算キロ： 182.0 km
運賃：\3,260     \2,600[2割引] \3,260[周割] \6,520[往復] \1,950[4割引]
有効日数：   2日

下関-岩国
経由：山陽線<櫛ヶ浜>岩徳線
営業キロ： 182.0 km 計算キロ： 182.0 km
運賃：\3,260     \2,600[2割引] \3,260[周割] \6,520[往復] \1,950[4割引]
有効日数：   2日

fare_info.calc_fare:
	FARE_INFO::aggregate_fare_info(ite->lineId, station_id1, ite->stationId)) {
		FARE_INFO::CheckSpecficFarePass(line_id, station_id1, station_id2);	// 特別加算区間（同一会社発着)
		FARE_INFO::Fare_company(station_id1, station_id2);			// 会社線
	FARE_INFO::days_ticket(this->sales_km);						// JRのみの営業キロで86,87適用後の距離で計算すべき
	FARE_INFO::SpecficFareLine(routeList.front().stationId, routeList.back().stationId);	// 特例運賃

	* {は、ノード毎 インデント内は各ノードに対していおこなわれる.



route.checkOfRuleSpecificCoreLine:  86、87条、69条判定＆経路算出 showFare()の最初に呼ばれる
	Route::CheckOfRule86(route_list_raw, &exit, &enter, &cityId);
	Route::reRouteRule86j87j(cityId, chk, exit, enter);
		Route::SpecificCoreAreaFirstTransferStationBy(exit.lineId, IDENT1(cityId));
		Route::Retrieve_SpecificCoreStation(IDENT1(cityId));
		Route::SpecificCoreAreaFirstTransferStationBy(enter.lineId, IDENT2(cityId));
		Route::Retrieve_SpecificCoreStation(IDENT2(cityId));
	Route::ReRouteRule70j(route_list_raw, &route_list_cooked)
	Route::reRouteRule69j(route_tmp);			/* 69条適用(route_tmp->route_list_cooked) */
	Route::CheckOfRule87(route_list_raw);
	Route::CheckOfRule88j(&route_list_cooked);
	Route::CheckOfRule114j(route_list_raw, route_list_cooked, rtky & 0x03 | 0x8000);
	Route::reRouteRule86j87j(cityId, 2, exit, enter);
	Route::reRouteRule69j(route_tmp);			/* 69条適用(route_tmp->route_list_cooked) */
	Route::reRouteRule86j87j(cityId, 1, exit, enter);
	Route::reRouteRule69j(route_tmp);			/* 69条適用(route_tmp->route_list_cooked) */
	Route::CheckOfRule88j(&route_list_cooked);
	Route::CheckOfRule114j(route_list_raw, route_list_cooked, chk & 0x03);







----------------------------------------------------------------

// 往復割引 1割引き 端数切り捨て 10190 → 9170

#if 0
利用区間に新下関～博多間を含む場合は、新幹線と在来線とでは運賃が異なります。
この例の場合の運賃計算は次のとおりです。
ゆきは新幹線利用で本州内幹線の運賃を適用し、運算計算キロは1179.3kmで13,440円。
片道1割引で12,090円。かえりは在来線利用で博多～東京間の運賃計算キロは1179.3kmで
「本州3社内の幹線の普通運賃表」を適用した13,440円にJR九州利用分（博多～下関間79km）の
加算額150円を加え、13,590円。片道1割引で12,230円になります。
往復割引運賃は12,090円＋12,230円＝24,320円です。


#endif

// デバック----------------------------------------------------------------

#if 0	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  計算キロ220km～で、都区市内適用されていない場合、114条を試みる？
					Route::CheckOfRule114j(route, route_new, rtky & 0x03 | 0x8000)

	if (1900 < sales_km) {
		Route::CheckOfRule114j(route, route_new, rtky & 0x03 | 0x8000);
	}

	長津田-国母の例
	国母は横浜から200


...............
viewDidAppear   viewContextMode をセット
actionSelectProcFrom   longTermFuncMode
processDuringIndicatorAnimating


doneTerminal segue
 viewContextMode = .ROUTESETUP_VIEW;
 self.routeScript = routeViewCtrl.selectRouteString;
viewDidAppear
 　longTermFuncMode = .SETUPROUTE;
  長い処理を仕掛ける　引数にScriptを渡しているがメンバ変数にしているので意味なし。相手も拾えるって。 longTermFuncModeもそうだし。

長い処理：processDuringIndicatorAnimating
  longTermFuncModeで分岐 setup_route()する。あとよろ
